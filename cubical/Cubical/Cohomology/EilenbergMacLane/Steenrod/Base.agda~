{-# OPTIONS --safe --lossy-unification #-}

{-
This file contiains.
-}

module Cubical.Cohomology.EilenbergMacLane.Steenrod.Base where

open import Cubical.Cohomology.EilenbergMacLane.Base
open import Cubical.Cohomology.EilenbergMacLane.Groups.Sn
open import Cubical.Cohomology.EilenbergMacLane.CupProduct
open import Cubical.Cohomology.EilenbergMacLane.Gysin
open import Cubical.Cohomology.EilenbergMacLane.Rings.RPinf

open import Cubical.Homotopy.EilenbergMacLane.CupProduct
open import Cubical.Homotopy.EilenbergMacLane.CupProductTensor
  renaming (_⌣ₖ_ to _⌣ₖ⊗_ ; ⌣ₖ-0ₖ to ⌣ₖ-0ₖ⊗ ; 0ₖ-⌣ₖ to 0ₖ-⌣ₖ⊗)
open import Cubical.Homotopy.Connected
open import Cubical.Homotopy.EilenbergMacLane.GradedCommTensor
  hiding (⌣ₖ-comm)
open import Cubical.Homotopy.EilenbergMacLane.GroupStructure
open import Cubical.Homotopy.EilenbergMacLane.Base
open import Cubical.Homotopy.EilenbergMacLane.Properties
open import Cubical.Homotopy.Loopspace
open import Cubical.Homotopy.Group.Base
open import Cubical.Homotopy.EilenbergMacLane.Order2

open import Cubical.Functions.Morphism
open import Cubical.Functions.Embedding
open import Cubical.Functions.Surjection

open import Cubical.Foundations.Prelude
open import Cubical.Foundations.Transport
open import Cubical.Foundations.HLevels
open import Cubical.Foundations.Function
open import Cubical.Foundations.GroupoidLaws
open import Cubical.Foundations.Path
open import Cubical.Foundations.Equiv
open import Cubical.Foundations.Pointed
open import Cubical.Foundations.Pointed.Homogeneous
open import Cubical.Foundations.Isomorphism
open import Cubical.Foundations.Equiv.HalfAdjoint
open import Cubical.Foundations.Univalence

open import Cubical.HITs.PropositionalTruncation as PT
open import Cubical.HITs.SetTruncation as ST
open import Cubical.HITs.Truncation as TR
open import Cubical.HITs.Sn hiding (S)
open import Cubical.HITs.Pushout
open import Cubical.HITs.EilenbergMacLane1
open import Cubical.HITs.Susp
open import Cubical.HITs.S1
open import Cubical.HITs.RPn
open import Cubical.HITs.RPn.Unordered
open import Cubical.HITs.RPn.JoinFubini
open import Cubical.HITs.Join
open import Cubical.HITs.SmashProduct

open import Cubical.Data.Empty as ⊥
open import Cubical.Relation.Nullary


open import Cubical.Data.Unit
open import Cubical.Data.Nat
open import Cubical.Data.Nat.Order hiding (eq)
open import Cubical.Data.Sigma
open import Cubical.Data.Bool hiding (_≤_)

open import Cubical.Algebra.Group.Base
open import Cubical.Algebra.AbGroup.Base
open import Cubical.Algebra.Group.MorphismProperties
open import Cubical.Algebra.Group.Morphisms
open import Cubical.Algebra.Ring
open import Cubical.Algebra.CommRing
open import Cubical.Algebra.CommRing.Instances.IntMod
open import Cubical.Algebra.Group.Instances.IntMod

open import Cubical.Data.Fin.Arithmetic
open import Cubical.Data.Fin.Base


open RingStr renaming (_+_ to _+r_)
open PlusBis

open Iso

lastˣ : ∀ {ℓ} (A : ℕ → Type ℓ) (n : ℕ) → A ˣ n → A n
lastˣ A zero x = x
lastˣ A (suc n) x = snd x

projˣ : ∀ {ℓ} (A : ℕ → Type ℓ) (n m : ℕ) (p : m ≤ n) → A ˣ n → A m
projˣ A n m (zero , p) x = subst A (sym p) (lastˣ A n x)
projˣ A zero m (suc diff , p) x = ⊥.rec (snotz p)
projˣ A (suc n) m (suc diff , p) (x , y) = projˣ A n m (diff , cong predℕ p) x

projTot :  ∀ {ℓ} (A : ℕ → Pointed ℓ) (n m : ℕ) → (fst ∘ A) ˣ n → (fst ∘ A) m
projTot A n m with (m Cubical.Data.Nat.Order.≟ n)
... | lt x = projˣ (fst ∘ A) n m (<-weaken x) 
... | Trichotomy.eq x = projˣ (fst ∘ A) n m (0 , x) 
... | gt x = λ x → A m .snd

projTot0 : ∀ {ℓ} (A : ℕ → Pointed ℓ) (n m : ℕ) (p : n < m) (x : (fst ∘ A) ˣ n)
  → projTot A n m x ≡ snd (A m)
projTot0 A n m p x with (m Cubical.Data.Nat.Order.≟ n)
... | lt q = ⊥.rec (¬m<m (<-trans q p))
... | Trichotomy.eq x₁ = ⊥.rec (¬m<m (subst (_< m) (sym x₁) p))
... | gt x₁ = refl

_ˣ̂_ : ∀ {ℓ} (A : ℕ → Pointed ℓ) (n : ℕ) → Type ℓ
A ˣ̂ n = Σ[ A' ∈ ((n : ℕ) → A n .fst) ] ((k : ℕ) → A' (suc k + n) ≡ snd (A (suc (k + n))))

-- lowerˣ̂ : ∀ {ℓ} (A : ℕ → Pointed ℓ) (n : ℕ) → A ˣ̂(suc n) → A ˣ̂ n
-- fst (lowerˣ̂ A n (f , p)) k with (k Cubical.Data.Nat.Order.≟ n)
-- ... | lt x₁ = A k .snd
-- ... | Trichotomy.eq x₁ = A k .snd
-- ... | gt x₁ = f k
-- snd (lowerˣ̂ A n (f , p)) zero with ((suc (zero + n)) Cubical.Data.Nat.Order.≟ n)
-- ... | lt x = refl
-- ... | Trichotomy.eq x = refl
-- ... | gt x = {!x!}
-- snd (lowerˣ̂ A n (f , p)) (suc k)
--   with ((suc (suc k + n)) Cubical.Data.Nat.Order.≟ n)
-- ... | lt x₁ = refl
-- ... | Trichotomy.eq x₁ = refl
-- ... | gt x₁ = λ i
--   → comp (λ j → A (suc (+-suc k n j)) .fst)
--           (λ j → λ {(i = i0) → f (suc (+-suc k n j))
--                    ; (i = i1) → snd (A (suc (+-suc k n j)))})
--           (p k i)

-- ˣ̂→ˣ : ∀ {ℓ} (A : ℕ → Pointed ℓ) (n : ℕ) → A ˣ̂ n → (fst ∘ A) ˣ n
-- ˣ̂→ˣ A zero f = f .fst zero
-- ˣ̂→ˣ A (suc n) f = ˣ̂→ˣ A n {!!} , f .fst (suc n)

-- ˣIsoˣ̂ : ∀ {ℓ} (A : ℕ → Pointed ℓ) (n : ℕ) → Iso ((fst ∘ A) ˣ n) (A ˣ̂ n)
-- fst (fun (ˣIsoˣ̂ A n) f) m = projTot A n m f
-- snd (fun (ˣIsoˣ̂ A n) f) k = projTot0 A n (suc k + n) (k , +-suc k n) f
-- inv (ˣIsoˣ̂ A n) = ˣ̂→ˣ A n
-- rightInv (ˣIsoˣ̂ A n) = {!!}
-- leftInv (ˣIsoˣ̂ A n) = {!!}


-- 1. Construction of the steenrod squares
{-
Idea : We know that
  (RP∞ → EM ℤ/2 n → EM ℤ/2 (n + n)) ≃
  (EM ℤ/2 n → EM ℤ/2 0 × ... × EM ℤ/2 (n + n))

The RHS of this equivalence is the type of the total Steendrod square
(with the invidivual squares Sqⁱ given by taken i:th projection). To
define it, we work on the LHS of the equivalence.

We can generalise the LHS: Given a point (X : RP∞) and a function n :
X → ℕ, we may consider the sum of n, defined as follows:
-}

∑RP∞' : (X : RP∞' ℓ-zero) (n : fst X → ℕ) → ℕ
∑RP∞' X n =
  RP∞'→SetRec isSetℕ X
   (λ x → n x +' n (RP∞'-fields.notRP∞' X x))
   λ x → +'-comm (n x) _ ∙ cong (n (RP∞'-fields.notRP∞' X x) +'_)
                           (cong n (sym (notNotRP∞' X x)))

∑RP∞'≡ : (X : RP∞' ℓ-zero) (x : fst X) (n : fst X → ℕ)
  → ∑RP∞' X n ≡ n x +' n (RP∞'-fields.notRP∞' X x)
∑RP∞'≡ = RP∞'pt→Prop (λ _ → isPropΠ2 λ _ _ → isSetℕ _ _)
  λ { false n → +'-comm (n true) (n false)
     ; true n → refl}

{-
We may now ask: is there a function S_X taking undordered pairs
  (p : Π[ x : X ] (EM ℤ/2 (n x))) to EM ℤ/2 (∑ n).

In the special case when n is constant, we may define the total
Steenrod square S : (RP∞ → EM ℤ/2 n → EM ℤ/2 (n + n)) by taking the
diagonal of the above construction S(X,x) := S_X (λ _ → x)

So, the challenge: define, for each X : RP∞ and n : X → ℕ a function
of type Π[ x : X ] (EM ℤ/2 (n x)) → EM ℤ/2 (∑ n).

It's easy to do this when X is Bool (just take the cup product).

Problem: Woud like (Π[ x : X ] (EM ℤ/2 (n x)) → EM ℤ/2 (∑ n)) to be at
least an hSet for this argument to work.

Solution: beef up
  (Π[ x : X ] (EM ℤ/2 (n x)) → EM ℤ/2 (∑ n))
with a structure turning it into an
hSet -}

-- The relation
module _ {ℓ} (X : RP∞' ℓ) (A : fst X → Pointed ℓ) (B : Pointed ℓ) where
  BipointedUnordJoin : (f : ((x : fst X) → A x .fst) → fst B) → Type ℓ
  BipointedUnordJoin f =
      (g : (x : fst X) → A x .fst)
    → UnordJoinR X (λ x → g x ≡ A x .snd)
    → f g ≡ B .snd

-- The 'full' type of steenrod squares.
SteenrodFunType : (X : RP∞' ℓ-zero) (n : fst X → ℕ) → Type
SteenrodFunType X n =
  Σ[ f ∈ (((x : fst X) → EM ℤ/2 (n x)) → EM ℤ/2 (∑RP∞' X n)) ]
    BipointedUnordJoin X (λ x → EM∙ ℤ/2 (n x)) (EM∙ ℤ/2 (∑RP∞' X n)) f

-- Goal: Show that SteenrodFunType is simply the type of bipointed
-- functions when X is Bool. This allows us, in particular, to
-- conclude that it is an hSet.

-- We characterise the structure BipointedJoinBool in this case
module _ {ℓ} (A B T :  Pointed ℓ)
         (f : fst A → fst B → fst T) where
  BipointedJoinBool : Type ℓ
  BipointedJoinBool = (a : A .fst) (b : B .fst)
      → join (a ≡ A .snd) (b ≡ B .snd)
      → f a b ≡ T .snd

  JS'r : singl (pt B) → Type ℓ
  JS'r (b , p) = (a : fst A) → f a b ≡ T .snd

  BipointedJoinBool' : Type ℓ
  BipointedJoinBool' =
    Σ[ l ∈ ((a : singl (pt A)) (b : fst B) → f (fst a) b ≡ T .snd) ]
    Σ[ r ∈ ((b : singl (pt B)) (a : fst A) → f a (fst b) ≡ T .snd) ]
      ((a : _) (b : _) → l a (fst b) ≡ r b (fst a))

  BipointedJoinBool'' : Type ℓ
  BipointedJoinBool'' =
    Σ[ l ∈ ((b : fst B) → f (pt A) b ≡ T .snd) ]
    Σ[ r ∈ ((a : fst A) → f a (pt B) ≡ T .snd) ]
      l (pt B) ≡ r (pt A)

  IsoBipointedJoinBool₁ : Iso BipointedJoinBool BipointedJoinBool'
  fst (Iso.fun IsoBipointedJoinBool₁ F) (a , p) b = F a b (inl (sym p))
  fst (snd (Iso.fun IsoBipointedJoinBool₁ F)) (b , p) a = F a b (inr (sym p))
  snd (snd (Iso.fun IsoBipointedJoinBool₁ F)) (a , p) (b , q) =
    cong (F a b) (push (sym p) (sym q))
  Iso.inv IsoBipointedJoinBool₁ (l , r , lr) a b (inl x) = l (a , sym x) b
  Iso.inv IsoBipointedJoinBool₁ (l , r , lr) a b (inr x) = r (b , sym x) a
  Iso.inv IsoBipointedJoinBool₁ (l , r , lr) a b (push p q i) = lr (a , sym p) (b , sym q) i
  Iso.rightInv IsoBipointedJoinBool₁ _ = refl
  Iso.leftInv IsoBipointedJoinBool₁ F = funExt λ a → funExt λ b → funExt
    λ { (inl x) → refl ; (inr x) → refl ; (push a b i) → refl}

  IsoBipointedJoinBool₂ : Iso BipointedJoinBool' BipointedJoinBool''
  IsoBipointedJoinBool₂ = compIso
    (Σ-cong-iso
      {B = λ l → Σ[ r ∈ ((b : singl (pt B)) (a : fst A) → f a (fst b) ≡ T .snd) ]
                   ((a : _) (b : _) → l a (fst b) ≡ r b (fst a))}
      {B' = λ l → Σ[ r ∈ ((b : singl (pt B)) (a : fst A) → f a (fst b) ≡ T .snd) ]
                   ((b : _) → l (fst b) ≡ r b (pt A))}
      (DomainContrIso (isContrSingl (pt A)))
        λ x → Σ-cong-iso-snd λ r → DomainContrIso (isContrSingl (pt A)))
      (Σ-cong-iso-snd
        λ l → Σ-cong-iso {B = λ r → ((b : _) → l (fst b) ≡ r b (pt A))}
                          {B' = λ r → (l (pt B) ≡ r (pt A))}
      (DomainContrIso (isContrSingl (pt B)))
      λ _ → DomainContrIso (isContrSingl (pt B)))

  IsoBipointedJoinBool₃ : Iso BipointedJoinBool BipointedJoinBool''
  IsoBipointedJoinBool₃ = compIso IsoBipointedJoinBool₁ IsoBipointedJoinBool₂

-- Characterisation of the type of functions with a BipointedJoinBool
-- structure
module _ (A B T : Pointed ℓ-zero) where
  Iso-ΣBipointedJoinBool-⋀→∙ :
    Iso (Σ[ f ∈ (fst A → fst B → fst T) ] BipointedJoinBool A B T f)
        (A ⋀∙ B →∙ T)
  Iso-ΣBipointedJoinBool-⋀→∙ =
    compIso (Σ-cong-iso-snd (λ f → IsoBipointedJoinBool₃ A B T f)) main
    where
    F : (T : Type) (t : T)
      → Σ[ f ∈ (fst A → fst B → T) ]
          BipointedJoinBool'' A B (T , t) f → (A ⋀∙ B →∙ (T , t))
    fst (F T t (f , fl , fr , flr)) (inl x) = t
    fst (F T t (f , fl , fr , flr)) (inr x) = f (fst x) (snd x)
    fst (F T t (f , fl , fr , flr)) (push (inl x) i) = fr x (~ i)
    fst (F T t (f , fl , fr , flr)) (push (inr x) i) = fl x (~ i)
    fst (F T t (f , fl , fr , flr)) (push (push a i₁) i) = flr (~ i₁) (~ i)
    snd (F T t (f , fl , fr , flr)) = refl

    G-pre : (T : Type) (f : A ⋀ B → T)
      → Σ[ g ∈ (fst A → fst B → T) ] BipointedJoinBool'' A B (T , f (inl tt)) g
    fst (G-pre T f) a b = f (inr (a , b))
    fst (snd (G-pre T f)) b = cong f (sym (push (inr b)))
    fst (snd (snd (G-pre T f))) c = cong f (sym (push (inl c)))
    snd (snd (snd (G-pre T f))) j i = f (push (push tt (~ j)) (~ i))

    G-snd : (T : Type) (f : A ⋀ B → T) (t : T)
      → (f (inl tt) ≡ t)
      → BipointedJoinBool'' A B (T , t) (λ a b → f (inr (a , b)))
    G-snd T f = J> G-pre T f .snd

    G : (T : Type) (f : A ⋀ B → T) (t : T)
      → (f (inl tt) ≡ t)
      → Σ[ f ∈ (fst A → fst B → T) ] BipointedJoinBool'' A B (T , t) f
    fst (G T f t x) a b = f (inr (a , b))
    snd (G T f t x) = G-snd T f t x

    F∘G≡ : (T : Type) (f : A ⋀ B → T) (t : T) (p : f (inl tt) ≡ t)
      → F T t (G T f t p) ≡ (f , p)
    F∘G≡ T f =
      J> cong (F T (f (inl tt)))
          (ΣPathP (refl , (transportRefl (G-pre T f .snd))))
       ∙ ΣPathP ((funExt (
               λ { (inl x) → refl
                 ; (inr x) → refl
                 ; (push (inl x) i) → refl
                 ; (push (inr x) i) → refl
                 ; (push (push a i₁) i) → refl})) , refl)

    main : Iso (Σ[ f ∈ (fst A → fst B → fst T) ] BipointedJoinBool'' A B T f)
              (A ⋀∙ B →∙ T)
    Iso.fun main f = F (fst T) (snd T) f
    Iso.inv main f = G (fst T) (fst f) (snd T) (snd f)
    Iso.rightInv main f = F∘G≡ (fst T) (fst f) _ (snd f)
    Iso.leftInv main f = ΣPathP (refl , transportRefl (snd f))

  Iso-ΣBipointedJoinBool-Bipointed :
     Iso (Σ[ f ∈ (fst A → fst B → fst T) ] BipointedJoinBool A B T f)
          (A →∙ (B →∙ T ∙))
  Iso-ΣBipointedJoinBool-Bipointed =
    compIso (Iso-ΣBipointedJoinBool-⋀→∙) SmashAdjIso

Iso-BipointedUnordJoin-BipointedJoinBool :
  ∀ {ℓ} (A : Bool → Pointed ℓ) (B : Pointed ℓ)
  → (f : ((x : Bool) → A x .fst) → fst B)
  → Iso (BipointedUnordJoin (RP∞'∙ ℓ) A B f)
         (BipointedJoinBool (A true) (A false) B
           λ a b → f (CasesBool true a b))
Iso-BipointedUnordJoin-BipointedJoinBool A B f =
  compIso (codomainIsoDep (λ g → domIso join-UnordJoinR-iso))
    (compIso (ΠIso ΠBool×Iso λ g
      → codomainIso (pathToIso
        (cong (_≡ B .snd) (cong f (sym (CasesBoolη g)))))) curryIso)

-- SteenrodFunType at Bool is Bipointed maps
isSetSteenrodFunTypeBoolIso : (n : Bool → ℕ)
  → Iso (SteenrodFunType (RP∞'∙ ℓ-zero) n)
         (EM∙ ℤ/2 (n true) →∙ (EM∙ ℤ/2 (n false) →∙ EM∙ ℤ/2 (n true +' n false) ∙))
isSetSteenrodFunTypeBoolIso n =
  (compIso (Σ-cong-iso-snd (λ f → Iso-BipointedUnordJoin-BipointedJoinBool _ _ _))
    (compIso (invIso (Σ-cong-iso (compIso (invIso curryIso)
                                  (invIso (ΠIso ΠBool×Iso λ f → idIso)))
                      λ g → idIso))
    (Iso-ΣBipointedJoinBool-Bipointed (EM∙ ℤ/2 (n true)) (EM∙ ℤ/2 (n false))
             (EM∙ ℤ/2 (n true +' n false)))))

-- Corollary 1: SteenrodFunType is always a set
isSetSteenrodFunType : (X : RP∞' ℓ-zero) (n : fst X → ℕ)
  → isSet (SteenrodFunType X n)
isSetSteenrodFunType = RP∞'pt→Prop (λ _ → isPropΠ λ _ → isPropIsOfHLevel 2)
  λ n → isOfHLevelRetractFromIso 2
  (isSetSteenrodFunTypeBoolIso n)
  (isConnected→∙ (suc (n true)) 1
  (isConnectedEM (n true))
  (subst (λ m → isOfHLevel m (EM∙ ℤ/2 (n false) →∙ EM∙ ℤ/2 (n true +' n false)))
         (cong suc (+-comm 1 (n true)) )
         (isConnected→∙ (suc (n false)) (suc (n true))
           (isConnectedEM (n false))
           (subst (λ m → isOfHLevel (suc m) (EM ℤ/2 (n true +' n false)))
              (cong suc (+'≡+ (n true) (n false))
              ∙ (+-comm (suc (n true)) (n false)))
              (hLevelEM ℤ/2 (n true +' n false))))))

-- Corollay 2: To show that two elements (f , p) and (g , q) of type
-- SteenrodFunType are equal, it suffices to show that f ≡ g
SteenrodFunType≡ : (X : RP∞' ℓ-zero) (n : fst X → ℕ)
  (f g : SteenrodFunType X n)
  → fst f ≡ fst g
  → f ≡ g
SteenrodFunType≡ =
  RP∞'pt→Prop (λ X → isPropΠ4 λ n _ _ _ → isSetSteenrodFunType X n _ _)
   λ n f g p
    → sym (Iso.leftInv (isSetSteenrodFunTypeBoolIso n) f)
    ∙∙ cong (inv (isSetSteenrodFunTypeBoolIso n))
         (→∙Homogeneous≡ (isHomogeneous→∙ (isHomogeneousEM _))
           (funExt (λ x → →∙Homogeneous≡ (isHomogeneousEM _)
             (funExt λ y → transportRefl _
                          ∙ funExt⁻ p (×→ΠBool (x , y))
                          ∙ sym (transportRefl _)))))
    ∙∙ Iso.leftInv (isSetSteenrodFunTypeBoolIso n) g

-- We can now construct the Steenrod squares
⌣ₖ₂ : {n m : ℕ} → EM ℤ/2 n → EM ℤ/2 m → EM ℤ/2 (n +' m)
⌣ₖ₂ = _⌣ₖ_ {G'' = ℤ/2Ring}

-- To construct the steenrod squares, we need to:
-- a) construct the underlying function
--  Π[ x ∈ X ] (EM ℤ/2 (n x)) → EM ℤ/2 (∑ n) given
-- some (x : X)

preSq : (X : RP∞' ℓ-zero) (x : fst X) (n : fst X → ℕ)
     (f : ((x₁ : fst X) → EM ℤ/2 (n x₁))) → EM ℤ/2 (∑RP∞' X n)
preSq X x n f =
  subst (EM ℤ/2) (sym (∑RP∞'≡ X x n))
        (⌣ₖ₂ (f x) (f (RP∞'-fields.notRP∞' X x)))

-- This is the cup product when X is Bool
preSqBool : (n : Bool → ℕ) (f : ((x₁ : Bool) → EM ℤ/2 (n x₁)))
  → EM ℤ/2 (∑RP∞' (RP∞'∙ ℓ-zero) n)
preSqBool n f = ⌣ₖ₂ (f true) (f false)

preSqBool≡ : (n : Bool → ℕ) (f : ((x₁ : Bool) → EM ℤ/2 (n x₁)))
  → preSq (RP∞'∙ ℓ-zero) true n f ≡ preSqBool n f
preSqBool≡ n f = (λ j → subst (EM ℤ/2)
                     (isSetℕ _ _ (sym (∑RP∞'≡ (RP∞'∙ ℓ-zero) true n)) refl j)
                     (preSqBool n f))
           ∙ transportRefl _

-- We then need to b) show that this has a BipointedUnordJoin structure
preSqCoh : (X : RP∞' ℓ-zero) (x : fst X) (n : fst X → ℕ)
  → BipointedUnordJoin X (λ x₁ → EM∙ ℤ/2 (n x₁))
                          (EM∙ ℤ/2 (∑RP∞' X n)) (preSq X x n)
preSqCoh = JRP∞' λ n → Iso-BipointedUnordJoin-BipointedJoinBool
                        (λ x₁ → EM∙ ℤ/2 (n x₁))
                        (EM∙ ℤ/2 (∑RP∞' (RP∞'∙ ℓ-zero) n))
                        (preSq (RP∞'∙ ℓ-zero) true n) .Iso.inv
                        λ g x r → preSqBool≡ n _ ∙ preSqCohBool n g x r
  where
  preSqCohBool : (n : Bool → ℕ)
    → BipointedJoinBool (EM∙ ℤ/2 (n true)) (EM∙ ℤ/2 (n false))
                         (EM∙ ℤ/2 (∑RP∞' (RP∞'∙ ℓ-zero) n))
           (λ a b → preSqBool n (CasesBool true a b))
  preSqCohBool n =
    Iso-ΣBipointedJoinBool-⋀→∙ (EM∙ ℤ/2 (n true)) (EM∙ ℤ/2 (n false))
             (EM∙ ℤ/2 (∑RP∞' (RP∞'∙ ℓ-zero) n)) .Iso.inv
      (preSq' n ∘∙ (⋀→Smash , refl)) .snd
    where
    preSq' : (n : Bool → ℕ)
      → SmashPt (EM∙ ℤ/2 (n true)) (EM∙ ℤ/2 (n false))
      →∙ EM∙ ℤ/2 (n true +' n false)
    fst (preSq' n) basel = 0ₖ (n true +' n false)
    fst (preSq' n) baser = 0ₖ (n true +' n false)
    fst (preSq' n) (proj x y) = ⌣ₖ₂ x y
    fst (preSq' n) (gluel a i) = ⌣ₖ-0ₖ {G'' = ℤ/2Ring} (n true) (n false) a i
    fst (preSq' n) (gluer b i) = 0ₖ-⌣ₖ {G'' = ℤ/2Ring} (n true) (n false) b i
    snd (preSq' n) = refl

-- and finally, because the codomain is an hSet and not an hProp,
-- c) verify that this construction is invariant under negation on X.

preSqCohComm : (X : RP∞' ℓ-zero) (x : fst X) (n : fst X → ℕ)
  → Path (SteenrodFunType X n)
          (preSq X x n , preSqCoh X x n)
          (preSq X (RP∞'-fields.notRP∞' X x) n
            , preSqCoh X (RP∞'-fields.notRP∞' X x) n)
preSqCohComm =
  JRP∞' λ n → SteenrodFunType≡ (RP∞'∙ ℓ-zero) n _ _
    (funExt λ f
    → cong (subst (EM ℤ/2) (sym (∑RP∞'≡ (RP∞'∙ ℓ-zero) true n)))
            (⌣ₖ-commℤ/2 (n true) (n false) (f true) (f false))
     ∙ help _ (+'-comm (n false) (n true)) _
              (sym (∑RP∞'≡ (RP∞'∙ ℓ-zero) true n))
              (sym (∑RP∞'≡ (RP∞'∙ ℓ-zero) false n))
        (⌣ₖ₂ (f false) (f true)))
  where
  help : {n : ℕ} (m : ℕ) (p : n ≡ m) (l : ℕ) (q : m ≡ l) (r : n ≡ l)
    → (x : EM ℤ/2 n)
    → subst (EM ℤ/2) q (subst (EM ℤ/2) p x) ≡ subst (EM ℤ/2) r x
  help = J> (J> λ r x
    → transportRefl _
     ∙ λ j → subst (EM ℤ/2) (isSetℕ _ _ refl r j) x)

-- This gives the total Steenrod squares (as an element of SteenrodFunType)
SteenrodFun : (X : RP∞' ℓ-zero) (n : fst X → ℕ) → SteenrodFunType X n
SteenrodFun X n =
  RP∞'→SetRec
    (isSetSteenrodFunType X n) X
    (λ x → preSq X x n , preSqCoh X x n)
    (λ x → preSqCohComm X x n)

-- The total square without the additional structure
S : (X : RP∞' ℓ-zero) (n : fst X → ℕ)
       (f : ((x₁ : fst X) → EM ℤ/2 (n x₁))) → EM ℤ/2 (∑RP∞' X n)
S X n f = SteenrodFun X n .fst f

SteenrodFunId : (X : RP∞' ℓ-zero) (n : fst X → ℕ)
  (x : fst X) (g : (x₁ : fst X) → EM ℤ/2 (n x₁))
  → S X n g ≡ preSq X x n g
SteenrodFunId X n x g i =
  RP∞'→SetRecβ
    (isSetSteenrodFunType X n) X
    (λ x → preSq X x n , preSqCoh X x n)
    (λ x → preSqCohComm X x n) x i .fst g

SteenrodFunBool : (n : Bool → ℕ) (g : _)
  → S (RP∞'∙ ℓ-zero) n g ≡ ⌣ₖ₂ (g true) (g false)
SteenrodFunBool n g = SteenrodFunId (RP∞'∙ ℓ-zero) n true g ∙ preSqBool≡ n g

-- The total squares (with the expected type)
private
  makeSquare : (n : ℕ)
      → (EM ℤ/2 1 → EM ℤ/2 n → EM ℤ/2 (n +' n))
      → (EM ℤ/2 n → (EM ℤ/2) ˣ (n +' n))
  makeSquare n f y = Iso.fun (RP→EM-ℤ/2-CharacIso _) λ x → f x y

  makeSquare' : (n : ℕ)
      → (RP∞' ℓ-zero → EM ℤ/2 n → EM ℤ/2 (n +' n))
      → (EM ℤ/2 n → (EM ℤ/2) ˣ (n +' n))
  makeSquare' n f y = makeSquare n (λ x y → f (EM₁-ℤ/2→RP∞' x) y) y

∑RP∞'const : (X : RP∞' ℓ-zero) (n : ℕ) → ∑RP∞' X (λ _ → n) ≡ (n +' n)
∑RP∞'const = RP∞'pt→Prop (λ _ → isPropΠ λ _ → isSetℕ _ _) λ  _ → refl

SqTot : (n : ℕ) → EM ℤ/2 n → (EM ℤ/2) ˣ (n +' n)
SqTot n = makeSquare' n λ X y → subst (EM ℤ/2) (∑RP∞'const X n) (S X (λ _ → n) (λ _ → y))

SqIneq : (n i : ℕ) (p : i ≤ n) → (i +' n) ≤ (n +' n)
SqIneq n i p =
  subst2 _≤_ (sym (+'≡+ i n)) (sym (+'≡+ n n))
    (≤-+-≤ p (0 , refl))

Sq : (n i : ℕ) → (i ≤ n) → EM ℤ/2 n → EM ℤ/2 (i +' n)
Sq n i p x = projˣ (EM ℤ/2) (n +' n) (i +' n) (SqIneq n i p) (SqTot n x)


Π' : ∀ {ℓ} (A : ℕ → Pointed ℓ) (m : ℕ) → Type ℓ
Π' A m = Σ[ f ∈ ((n : ℕ) → A n .fst) ] ((k : ℕ) → f (suc k + m) ≡ snd (A (suc k + m)))

Πℕ-pick-fsts₁ : ∀ {ℓ} (A : ℕ → Type ℓ) (m : ℕ) → ((n : ℕ) → A n) → (A ˣ m)
Πℕ-pick-fsts₁ A zero f = f zero
Πℕ-pick-fsts₁ A (suc m) f = (Πℕ-pick-fsts₁ A m f) , (f (suc m))


projˣ-Πℕ-pick-fsts₁ : ∀ {ℓ} (A : ℕ → Type ℓ) (m n : ℕ) (p : n ≤ m) (f : (n : ℕ) → A n)
  → projˣ A m n p (Πℕ-pick-fsts₁ A m f) ≡ f n
projˣ-Πℕ-pick-fsts₁ A zero n (zero , p) f = fromPathP (λ i → f (p (~ i)))
projˣ-Πℕ-pick-fsts₁ A zero n (suc diff , p) f = ⊥.rec (snotz p)
projˣ-Πℕ-pick-fsts₁ A (suc m) n (zero , p) f = fromPathP (λ i → f (p (~ i)))
projˣ-Πℕ-pick-fsts₁ A (suc m) n (suc diff , p) f = projˣ-Πℕ-pick-fsts₁ A m n (diff , cong predℕ p) f

Πℕ-pick-fsts : ∀ {ℓ} (A : ℕ → Type ℓ) (m : ℕ) → ((n : ℕ) → A n) → (A ˣ m) × ((k : ℕ) → A (suc k + m))
Πℕ-pick-fsts A m f = Πℕ-pick-fsts₁ A m f , (λ k → f (suc k + m))

open import Cubical.Data.Sum
Dichotomyℕ : ∀ (n m : ℕ) → (n ≤ m) ⊎ (n > m)
Dichotomyℕ n m with (Cubical.Data.Nat.Order._≟_ n m)
... | lt x = inl (<-weaken x)
... | Trichotomy.eq x = inl (0 , x)
... | gt x = inr x

0Π' : ∀ {ℓ} (n : ℕ) (A : ℕ → Pointed ℓ) → Π' A n 
fst (0Π' n A) m = snd (A m)
snd (0Π' n A) _ = refl

Π'↓₁ : ∀ {ℓ} (n : ℕ) (A : ℕ → Pointed ℓ) → Π' A (suc n) → (x : ℕ) → A x .fst
Π'↓₁ n A f m with (Dichotomyℕ m n)
... | inl x = fst f m
... | inr x = snd (A m)

Π'↓₁∙ : ∀ {ℓ} (n : ℕ) (A : ℕ → Pointed ℓ) → (k : ℕ) → Π'↓₁ n A (0Π' (suc n) A) k ≡ A k .snd
Π'↓₁∙ n A k with (Dichotomyℕ k n)
... | inl x = refl
... | inr x = refl

abstract
  Π'↓₂ : ∀ {ℓ} (n : ℕ) (A : ℕ → Pointed ℓ) (f : Π' A (suc n))
    → (k : ℕ) → Π'↓₁ n A f (suc (k + n)) ≡ snd (A (suc (k + n)))
  Π'↓₂ n A (f , p) k  with (Dichotomyℕ (suc (k + n)) n)
  ... | inl x = ⊥.rec (¬m<m (fst x + k
    , (+-assoc (fst x) k (suc n) ⁻¹ ∙ cong (fst x +_) (+-suc k n)) ∙ snd x))
  ... | inr x = refl

Π'↓ : ∀ {ℓ} (n : ℕ) (A : ℕ → Pointed ℓ) → Π' A (suc n) → Π' A n
fst (Π'↓ n A f) = Π'↓₁ n A f
snd (Π'↓ n A f) = Π'↓₂ n A f 

Π'↑ : ∀ {ℓ} (n : ℕ) (A : ℕ → Pointed ℓ)
  → A (suc n) .fst → Π' A n → Π' A (suc n)
fst (Π'↑ n A x f) m with (Cubical.Data.Nat.Order._≟_ m (suc n))
... | lt x₁ = fst f m
... | Trichotomy.eq x₁ = subst (fst ∘ A) (sym x₁) x
... | gt x₁ = snd (A m)
snd (Π'↑ n A x f) k with (Cubical.Data.Nat.Order._≟_ (k + suc n) n)
... | lt x₁ = subst (λ n → fst f n ≡ snd (A n)) (cong suc (sym (+-suc k n))) (f .snd (suc k))
... | Trichotomy.eq x₁ = ⊥.rec (¬m<m (k , x₁))
... | gt x₁ = refl

Π'≡ : ∀ {ℓ} (A : ℕ → Pointed ℓ) (m : ℕ) {f g : Π' A m}
  → ((k : ℕ) → k ≤ m → fst f k ≡ fst g k) → f ≡ g
Π'≡ A m {f = f} {g} p = ΣPathP ((funExt help) , funExt p2)
  where
  h2-fill : (n : ℕ) (i j : I) (p : m < n) → fst (A _)
  h2-fill n i j (x , p) =
    fill (λ k → fst (A ((sym (+-suc x m) ∙ p) k)))
         (λ k → λ {(i = i0) → fst f ((sym (+-suc x m) ∙ p) k)
                  ; (i = i1) → fst g ((sym (+-suc x m) ∙ p) k)})
         (inS ((snd f x ∙∙ refl ∙∙ sym (snd g x)) i)) j

  help : (x : _) → fst f x ≡ fst g x
  help n with (Dichotomyℕ n m)
  ... | inl x = p n x
  ... | inr (x , p) = (λ i → h2-fill n i i1 (x , p))

  p2 : (x : ℕ) →
      PathP (λ z → help (suc (x + m)) z ≡ snd (A (suc (x + m))))
            (snd f x) (snd g x)
  p2 x with (Dichotomyℕ (suc (x + m)) m)
  ... | inl x₁ = ⊥.rec (¬m<m (fst x₁ + x
    , (sym (+-assoc (fst x₁) x (suc m))
    ∙ cong (fst x₁ +_) (+-suc x m)) ∙ snd x₁))
  ... | inr x₁ = λ i j →
       comp (λ k → fst (A (((sym (+-suc (fst x₁) m)) ∙ snd x₁) k)))
            (λ k → λ {(i = i0) → help2 (fst f) (snd f) (fst x₁) x
                                    (inj-+m (snd x₁ ∙ sym (+-suc x m)))
                                    ((sym (+-suc (fst x₁) m)) ∙ snd x₁) k j
                     ; (i = i1) → help2 (fst g) (snd g) (fst x₁) x
                                    (inj-+m (snd x₁ ∙ sym (+-suc x m)))
                                    ((sym (+-suc (fst x₁) m)) ∙ snd x₁) k j
                     ; (j = i0) → h2-fill (suc (x + m)) i k x₁
                     ; (j = i1) → snd (A (((sym (+-suc (fst x₁) m)) ∙ snd x₁) k))})
            (doubleCompPath-filler (snd f (fst x₁)) refl (sym (snd g (fst x₁))) (~ j) i)
    where
    help2 : (f : (n : ℕ) → A n .fst)
           (sndf : (k₁ : ℕ) → f (suc (k₁ + m)) ≡ snd (A (suc (k₁ + m))))
           (x₁ x : ℕ) (r : x₁ ≡ x)
         → (p : (suc (x₁ + m)) ≡ (suc (x + m)))
         → SquareP (λ i j → fst (A (p i))) (sndf x₁) (sndf x)
                    (cong f p) (cong (snd ∘ A) p)
    help2 f sndf x₁ = J> λ p
      → subst (λ p → SquareP (λ i j → fst (A (p i))) (sndf x₁) (sndf x₁)
                               (cong f p) (cong ((λ r → snd r) ∘ A) p))
                               (isSetℕ _ _ refl p)
                               refl

Π'-ind : ∀ {ℓ} (n : ℕ) (A : ℕ → Pointed ℓ)
  → Iso (Π' A (suc n)) (A (suc n) .fst × Π' A n)
fun (Π'-ind n A) (f , p) = (f (suc n)) , Π'↓ n A (f , p)
inv (Π'-ind n A) (f , p) = Π'↑ n A f p
rightInv (Π'-ind n A) (f , p) =
  ΣPathP (l1 , Π'≡ A _ l2)
  where
  l2 : (k : ℕ) → (k ≤ n)
    → (snd (fun (Π'-ind n A) (inv (Π'-ind n A) (f , p)))) .fst k ≡ p .fst k
  l2 k r with (Dichotomyℕ k n)
  ... | inl x = l3
   where
   l3 : fst (Π'↑ n A f p) k ≡ p .fst k
   l3 with (k Cubical.Data.Nat.Order.≟ suc n)
   ... | lt x = refl
   ... | Trichotomy.eq x = ⊥.rec (¬m<m (fst r , (cong (fst r +_) (sym x)) ∙ snd r))
   ... | gt q = ⊥.rec (¬m<m (≤-trans q (suc (fst x) , cong suc (snd x) )))
  ... | inr x =
    ⊥.rec (¬m<m (fst x + fst r
      , (sym (+-assoc (fst x) (fst r) (suc k))
       ∙ cong (fst x +_) (+-suc (fst r) k))
      ∙ cong (fst x +_) (cong suc (snd r)) ∙ snd x))
  l1 : fst (Π'↑ n A f p) (suc n) ≡ f
  l1 with (n Cubical.Data.Nat.Order.≟ n)
  ... | lt x = ⊥.rec (¬m<m x)
  ... | Trichotomy.eq x = (λ i → subst (fst ∘ A) (isSetℕ _ _ (cong suc (sym x)) refl i) f)
                        ∙ transportRefl f
  ... | gt x = ⊥.rec (¬m<m x)
leftInv (Π'-ind n A) (f , p) = Π'≡ A _ help
  where
  h2 : (k : ℕ) (r : k < suc n) → fst (Π'↓ n A (f , p)) k ≡ f k
  h2 k q with (Dichotomyℕ k n)
  ... | inl x = refl
  ... | inr x = ⊥.rec (¬m<m
    (fst x + fst q , sym (+-assoc (fst x) (fst q) (suc k))
      ∙ cong (fst x +_) (snd q) ∙ snd x))
  help : (k : ℕ) →  k ≤ suc n
      → fst (inv (Π'-ind n A) (fun (Π'-ind n A) (f , p))) k ≡ f k
  help k q with (Cubical.Data.Nat.Order._≟_ k (suc n))
  ... | lt x = h2 k x
  ... | Trichotomy.eq x = fromPathP (λ i → f (x (~ i)))
  ... | gt x = ⊥.rec (¬m<m (fst x + fst q
      , (sym (+-assoc (fst x) (fst q) (suc k))
      ∙ cong (fst x +_) (+-suc (fst q) k))
      ∙ cong (fst x +_) (cong suc (snd q)) ∙ snd x))

Π'≅×₀ : ∀ {ℓ} (A : ℕ → Pointed ℓ)
  → Iso (Π' A 0) (A 0 .fst)
fun (Π'≅×₀ A) (f , p) = f zero
fst (inv (Π'≅×₀ A) a) zero = a
fst (inv (Π'≅×₀ A) a) (suc x) = A (suc x) .snd
snd (inv (Π'≅×₀ A) a) = λ _ → refl
rightInv (Π'≅×₀ A) a = refl
leftInv (Π'≅×₀ A) (f , p) = Π'≡
  A _ λ { zero → λ _ → refl ; (suc k) p → ⊥.rec (snotz (sym (+-suc (fst p) k) ∙ snd p))}

Π'≅× : ∀ {ℓ} (n : ℕ) (A : ℕ → Pointed ℓ)
  → Iso (Π' A n) ((fst ∘ A) ˣ n)
Π'≅× zero A = Π'≅×₀ A
Π'≅× (suc n) A = compIso (Π'-ind n A) (compIso Σ-swap-Iso (prodIso (Π'≅× n A) idIso))

-- Πℕ-toFun : ∀ {ℓ} (A : ℕ → Type ℓ) (m : ℕ) → (A ˣ m) × ((k : ℕ) → A (suc k + m)) → ((n : ℕ) → A n)
-- Πℕ-toFun A m (f , p) n with (Dichotomyℕ n m)
-- ... | inl x = projˣ A m n x f
-- ... | inr x = subst A (sym (+-suc (fst x) m) ∙ snd x) (p (fst x))

-- ΠℕIso : ∀ {ℓ} (A : ℕ → Type ℓ) (m : ℕ) → Iso (((n : ℕ) → A n)) ((A ˣ m) × ((k : ℕ) → A (suc k + m)))
-- fun (ΠℕIso A m) = Πℕ-pick-fsts A m
-- inv (ΠℕIso A m) = Πℕ-toFun A m
-- rightInv (ΠℕIso A m) (f , fl) = ΣPathP (fs m f fl , funExt p2)
--   where
--   p2 : (x : ℕ) → Πℕ-toFun A m (f , fl) (suc (x + m)) ≡ fl x
--   p2 x with (Dichotomyℕ (suc (x + m)) m)
--   ... | inl x₁ = ⊥.rec (¬m<m (fst x₁ + x
--     , (sym (+-assoc (fst x₁) x (suc m))
--      ∙ cong (fst x₁ +_) (+-suc x m)) ∙ x₁ .snd))
--   ... | inr x₁ = (λ i → subst A (isSetℕ _ _ (sym (+-suc (fst x₁) m) ∙ snd x₁)
--                                   (cong (λ x → suc (x + m)) path) i)
--                            (fl (fst x₁))) ∙ fromPathP (cong fl path)
--     where
--     path : fst x₁ ≡ x
--     path = inj-+m (x₁ .snd ∙ sym (+-suc x m))

--   fs : (m : ℕ) (f : A ˣ m) (fl : _) → (fst (Πℕ-pick-fsts A m (Πℕ-toFun A m (f , fl))) ≡ f)
--   fs zero f fl = transportRefl f
--   fs (suc m) (f , fp) fl = ΣPathP (cong (Πℕ-pick-fsts₁ A m) (funExt help) ∙ fs m f (fl' m)
--     , help (suc m) ∙ help')
--     where
--     fl' : (n : ℕ) → ((k : ℕ) → A (suc (k + m)))
--     fl' n = Cubical.Data.Nat.elim fp
--        (λ n _ → subst A (λ i → suc (+-suc n m i)) (fl n))

--     help-inl : (n : ℕ) (x : _) → projˣ A (suc m) n x (f , fp) ≡ Πℕ-toFun A m (f , fl' n) n
--     help-inl n (zero , p) with (Dichotomyℕ n m)
--     ... | inl (diff , q) = ⊥.rec (¬m<m (diff , +-suc diff n ∙ cong suc q ∙ sym p))
--     ... | inr (zero , q) = λ i → subst A (isSetℕ _ _ (sym p) (refl ∙ q) i) fp
--     ... | inr (suc diff , q) = ⊥.rec (¬m<m (diff , cong predℕ (q ∙ p)))
--     help-inl n (suc diff , p) with (Dichotomyℕ n m)
--     ... | inl x = λ i → projˣ A m n (Cubical.Data.Nat.Order.isProp≤ {n} {m} (diff , (λ i₁ → predℕ (p i₁))) x i) f
--     ... | inr x = ⊥.rec (¬m<m ((fst x + diff)
--       , (sym (+-assoc (fst x) diff (suc n))
--         ∙ cong (fst x +_) (+-suc diff n))
--         ∙ cong (fst x +_) p ∙ (x .snd) ))


--     help-inr : (n : ℕ) (x : n > suc m)
--       → subst A ((λ i → +-suc (fst x) (suc m) (~ i)) ∙ snd x) (fl (fst x))
--       ≡ Πℕ-toFun A m (f , fl' n) n
--     help-inr n p with (Dichotomyℕ n m)
--     ... | inl x = ⊥.rec (¬m<m (fst x + (suc (fst p))
--       , (sym (+-assoc (fst x) (suc (fst p)) (suc m))
--         ∙ cong (fst x +_) (sym (+-suc (fst p) (suc m))))
--         ∙ cong (fst x +_) (snd p) ∙ snd x))
--     ... | inr (zero , q) = ⊥.rec (¬m<m (fst p , (p .snd ∙ (sym q))))
--     ... | inr (suc x , q) = help x (fst p)
--            (sym (inj-+m (snd p ∙ sym q ∙ sym (+-suc x (suc m))))) _
--           (cong suc (+-suc x m)) _
--           (cong suc (sym (+-suc x m)) ∙ q) (sym (+-suc (fst p) (suc m)) ∙ snd p)
--       where
--       help : (x fp : ℕ) (_ : x ≡ fp) (h : ℕ) (p : suc (x + suc m) ≡ h)
--              (w : ℕ) (q : h ≡ w) (r : suc (fp + suc m) ≡ w)
--         → subst A r (fl fp) ≡ subst A q (subst A p (fl x))
--       help x = J> J> J> λ r → (λ i → subst A (isSetℕ _ _ r refl i) (fl x))
--                               ∙ sym (transportRefl _)
   
   

--     help : (n : ℕ) → Πℕ-toFun A (suc m) ((f , fp) , fl) n
--                      ≡ Πℕ-toFun A m (f , fl' n) n
--     help n with (Dichotomyℕ n (suc m))
--     ... | inl x = help-inl n x
--     ... | inr x = help-inr n x

--     help' : Πℕ-toFun A m (f , fl' (suc m)) (suc m) ≡ fp
--     help' with (Dichotomyℕ (suc m) m)
--     ... | inl x = ⊥.rec (¬m<m x)
--     ... | inr (zero , p) =
--       (λ i → subst A (isSetℕ _ _ (refl ∙ p) refl i) fp) ∙ transportRefl fp
--     ... | inr (suc x , p) = ⊥.rec (¬m<m (x , cong predℕ p))

-- leftInv (ΠℕIso A zero) f = funExt lem
--   where
--   lem : (n : ℕ) → Πℕ-toFun A zero (Πℕ-pick-fsts A zero f) n ≡ f n
--   lem n with (Dichotomyℕ n 0)
--   ... | inl (zero , p) = fromPathP λ i → f (p (~ i))
--   ... | inl (suc x , p) = ⊥.rec (snotz p)
--   ... | inr x = fromPathP λ i → f ((sym (+-suc (fst x) zero) ∙ snd x) i)
-- leftInv (ΠℕIso A (suc m)) f = funExt lem
--   where
--   lem : (n : ℕ) → Πℕ-toFun A (suc m) (Πℕ-pick-fsts A (suc m) f) n ≡ f n
--   lem n with (Dichotomyℕ n (suc m))
--   ... | inl (x , p) = projˣ-Πℕ-pick-fsts₁ A (suc m) n (x , p) f
--   ... | inr x = fromPathP λ i → f ((sym (+-suc (fst x) (suc m)) ∙ snd x) i)

-- ΠℕIso' : ∀ {ℓ} (A : ℕ → Pointed ℓ) (m : ℕ)
--   → Iso (Π' A m) (Σ[ f ∈ (((fst ∘ A) ˣ m) × ((k : ℕ) → fst (A (suc k + m)))) ]
--                   ((k : ℕ) → snd f k ≡ snd (A (suc k + m))))
-- ΠℕIso' A n = Σ-cong-iso (ΠℕIso (fst ∘ A) n)
--   λ f → idIso

-- Π'≡ : ∀ {ℓ} (A : ℕ → Pointed ℓ) (m : ℕ) {f g : Π' A m}
--   → fst f ≡ fst g → f ≡ g 
-- Π'≡ A m {f = f} {g = g} p =
--   Iso.inv (congIso (ΠℕIso' A m)) (ΣPathP ((ΣPathP ((cong (Πℕ-pick-fsts₁ (λ x → fst (A x)) m) p)
--          , (funExt (λ x → snd f x ∙∙ refl ∙∙ sym (snd g x)))))
--          , (funExt (λ x i j → doubleCompPath-filler (snd f x) refl (sym (snd g x)) (~ j) i))))

-- open import Cubical.Functions.FunExtEquiv

-- Πℕ≅ˣ : ∀ {ℓ} (A : ℕ → Pointed ℓ) (m : ℕ)
--   → Iso (Π' A m) ((fst ∘ A) ˣ m)
-- Πℕ≅ˣ A m = compIso (ΠℕIso' A m)
--   (compIso Σ-assoc-Iso (compIso (Σ-cong-iso-snd (λ f
--     → isContr→Iso (isOfHLevelRetractFromIso 0 (Σ-cong-iso-snd (λ g → compIso funExtIso symIso))
--       (isContrSingl (λ (k : ℕ) → snd (A (suc k + m))))) isContrUnit)) rUnit×Iso))

1Aˣ : ∀ {ℓ} (A : ℕ → Type ℓ) (0A : (n : ℕ) → A n) (1A : A zero) → (n : ℕ) → A ˣ n
1Aˣ A 0A 1A zero = 1A
1Aˣ A 0A 1A (suc n) = (1Aˣ A 0A 1A n) , 0A (suc n)

sum' : ∀ {ℓ} {A : ℕ → Type ℓ} {B : ℕ → Type ℓ}
  (plusA : {n : ℕ} → A n → A n → A n)
  (mult : (n m : ℕ) → A n → B m → A (n + m))
  (f : (n : ℕ) → A n) (g : (n : ℕ) → B n)
  (k : ℕ) → A k
sum' plus mult f g zero = mult zero zero (f zero) (g zero)
sum' {A = A} {B = B} _+A_ mult f g (suc k) =
  sum' {A = λ k → A (suc k)} {B = B}
       _+A_ (λ n → λ m → mult (suc n) m) (f ∘ suc) g k
  +A mult zero (suc k) (f zero) (g (suc k))


open import Cubical.Data.Vec.DepVec

∑⌣ : ∀ {ℓ} {A : ℕ → Type ℓ} (n m : ℕ)
  → (A ˣ n) → (A ˣ m)
  → (plusA : {n : ℕ} → A n → A n → A n)
  → (mult : (n m : ℕ) → A n → A m → A (n + m))
  → A ˣ (n + m)
∑⌣ zero zero x y plusA mult = mult zero zero x y
∑⌣ zero (suc m) x y plusA mult = (∑⌣ zero m x (fst y) plusA mult) , (mult zero (suc m) x (y .snd))
∑⌣ {A = A} (suc n) m x y plusA mult = (∑⌣ n m (fst x) y plusA mult) , (mult (suc n) m (snd x) (lastˣ A m y))

open import Cubical.Induction.WellFounded

_et_＝_ : (n m k : ℕ) → Type
n et m ＝ k = n + m ≡ k

sumUpTo : ∀ {ℓ} {A : ℕ → Type ℓ} (plusA : {n : ℕ} → A n → A n → A n) (toA : (m n : ℕ) → n ≤ m → A m) (m : ℕ) → A m
sumUpTo {A = A} plusA toA zero = toA zero zero (0 , refl)
sumUpTo {A = A} plusA toA (suc m) =
  plusA (sumUpTo {A = A ∘ suc} plusA (λ n m p → toA (suc n) m (≤-trans p (1 , refl))) m)
        (toA (suc m) (suc m) (0 , refl))

module _ {ℓ} {A : Type ℓ} (f : (n : ℕ) → A) (plusA : A → A → A) where
  sum-helper : (n : ℕ) → A
  sum-helper zero = f zero
  sum-helper (suc n) = plusA (sum-helper n) (f (suc n))

module _ {ℓ} {A : Type ℓ} (m : ℕ) (f : (n : ℕ) → n ≤ m → A) (plusA : A → A → A) where
  sum-helper≤ : (n : ℕ) → n ≤ m  → A
  sum-helper≤ zero p = f zero p
  sum-helper≤ (suc n) p = plusA (sum-helper≤ n (≤-trans (1 , refl) p)) (f (suc n) p)

  sum≤ : A
  sum≤ = sum-helper≤ m (0 , refl)

∸-+' : (k t : ℕ) → (k ∸ t) +' t ≡ k
∸-+' zero t = {!!}
∸-+' (suc k) t = {!!}

⌣ₖ₂' : (n m : ℕ) → EM ℤ/2 n → EM ℤ/2 m → EM ℤ/2 (n + m)
⌣ₖ₂' n m x y = subst (EM ℤ/2) (+'≡+ n m) (⌣ₖ₂ {n = n} {m} x y)

sumMultFun : ∀ {ℓ} {A : Type ℓ} (n m k : ℕ) → (f g : (n : ℕ) → A) → A
sumMultFun n m k = {!!}

EMℤ/2-sumFun : (k : ℕ) → (f g : (n : ℕ) → EM ℤ/2 n) → EM ℤ/2 k
EMℤ/2-sumFun k f g =
  sum≤ {A = EM ℤ/2 k} k
    (λ p r → subst (EM ℤ/2) (snd r)
               (⌣ₖ₂' (fst r) p (f (fst r)) (g p)))
    _+ₖ_


sum : {A : ℕ → Type}
  → (plusA : {n : ℕ} → A n → A n → A n)
  → (mult : (n m : ℕ) → A n → A m → A (n + m))
  → (f g : (n : ℕ) → A n)
  → (k : ℕ) → A k
sum {A = A} plusA mult f g k = sum≤ {A = A k} k
  (λ p r → subst A (snd r) (mult (fst r) p (f (fst r)) (g p))) plusA

flip¬≤ : (n : ℕ) (x : Fin (suc n)) → n ∸ (fst x) < suc n
flip¬≤ n (zero , p) = 0 , refl
flip¬≤ zero (suc x , p) = 0 , refl
flip¬≤ (suc n) (suc x , p) =
  <-trans (flip¬≤ n (x , pred-≤-pred p)) (0 , refl)

flipFin : (n : ℕ) → Fin (suc n) → Fin (suc n)
flipFin n x = (n ∸ (fst x)) , flip¬≤ n x

flipIdemP : (n : ℕ) (x : _) → flipFin n (flipFin n x) ≡ x
flipIdemP n (x , y , p) = Σ≡Prop (λ _ → Cubical.Data.Nat.Order.isProp≤)
  (cong (λ n → n ∸ (n ∸ x)) (cong predℕ (sym p ∙ +-suc y x))
  ∙ cong (y + x ∸_) (+∸ y x)
  ∙ ∸+ x y)

flipFinIso : (n : ℕ) → Iso (Fin (suc n)) (Fin (suc n))
fun (flipFinIso n) = flipFin n
inv (flipFinIso n) = flipFin n
rightInv (flipFinIso n) = flipIdemP n
leftInv (flipFinIso n) = flipIdemP n

flipFin' : (n : ℕ) → (Σ[ m ∈ ℕ ] (m ≤ n)) → (Σ[ m ∈ ℕ ] (m ≤ n))
flipFin' n (x , p) = t .fst , snd t .fst
  , cong predℕ (sym (+-suc (fst (snd t)) (fst t)) ∙ (snd t .snd))
  where
  t = flipFin n (x , fst p , +-suc (fst p) x ∙ cong suc (snd p))

flipFin'idemP : (n : ℕ) → (x : Σ[ m ∈ ℕ ] (m ≤ n)) → flipFin' n (flipFin' n x) ≡ x
flipFin'idemP n (x , p) = Σ≡Prop (λ _ → Cubical.Data.Nat.Order.isProp≤)
  (cong fst (flipIdemP n (x , fst p , +-suc (fst p) x ∙ cong suc (snd p))))

flipFinIso' : (n : ℕ) → Iso (Σ[ m ∈ ℕ ] (m ≤ n)) (Σ[ m ∈ ℕ ] (m ≤ n))
fun (flipFinIso' n) = flipFin' n
inv (flipFinIso' n) = flipFin' n
rightInv (flipFinIso' n) = flipFin'idemP n
leftInv (flipFinIso' n) = flipFin'idemP n

flipFinIso'' : {!(k : ℕ) → ℕ → ℕ!}
flipFinIso'' = {!!}

sum-helper≤-suc : ∀ {ℓ} {A : Type ℓ} (m : ℕ)
  (f : (n : ℕ) → n ≤ (suc m) → A) (plusA : A → A → A)
  (k : ℕ) (p : k ≤ m)
  → (sum-helper≤ {A = A} m (λ n p → f n (≤-trans p (1 , refl))) plusA k p)
   ≡ sum-helper≤ {A = A} (suc m) f plusA k (≤-trans p (1 , refl))
sum-helper≤-suc m f plusA zero p = refl
sum-helper≤-suc m f plusA (suc k) p =
  cong₂ plusA (sum-helper≤-suc m f plusA k
    (≤-trans (1 , (λ _ → suc k)) p)
     ∙ cong (sum-helper≤ (suc m) f plusA k) (Cubical.Data.Nat.Order.isProp≤ _ _))
    refl

f1' : ∀ {ℓ} {A : Type ℓ} (m : ℕ) (f : (n : ℕ) → n ≤ (suc m) → A) (plusA : A → A → A)
  → (plusAssoc : (x y z : A) → plusA x (plusA y z) ≡ plusA (plusA x y) z)
  → (k : _) {p : _} {q : _} {r : _}
  → sum-helper≤ {A = A} (suc m) f plusA (suc k) p
   ≡ plusA (f zero (suc m , q))
           (sum-helper≤ {A = A} m (λ n p → f (suc n) (suc-≤-suc p)) plusA k r)
f1' {A = A} m f plusA plusAssoc zero =
  cong₂ plusA (cong (f zero) (Cubical.Data.Nat.Order.isProp≤ _ _))
              (cong (f 1) (Cubical.Data.Nat.Order.isProp≤ _ _))
f1' {A = A} m f plusA plusAssoc (suc k) {p = p} {q = q} {r = r} =
     cong₂ plusA
       (f1' m f plusA plusAssoc k {p = (≤-trans (1 , (λ _ → 1 + suc k)) p)}
            {q = q}
            {r = ≤-trans (1 , (λ _ → 1 + k)) r})
       (cong (f (suc (suc k))) (Cubical.Data.Nat.Order.isProp≤ _ _))
   ∙ sym (plusAssoc (f zero (suc m , q))
                    (sum-helper≤ m (λ n p₁ → f (suc n) (suc-≤-suc p₁))
                      plusA k (≤-trans (1 , (λ _ → suc k)) r))
                    (f (suc (suc k)) (suc-≤-suc r)))

sum-comm' : {A : ℕ → Type}
  → (plusA : {n : ℕ} → A n → A n → A n)
  → (plusA-comm : {n : ℕ} → (x y : A n) → plusA x y ≡ plusA y x)
  → (plusAssoc : {n : ℕ} (x y z : A n) → plusA x (plusA y z) ≡ plusA (plusA x y) z)
  → (k : ℕ)
  → (f g : (n : ℕ) → n ≤ k → A k)
  → ((λ n p → f (k ∸ n) (Iso.fun (flipFinIso' k) (n , p) .snd)) ≡ g)
  → sum-helper≤ {A = A k} k f plusA k (0 , refl)
   ≡ sum-helper≤ {A = A k} k g plusA k (0 , refl)
sum-comm' {A = A} plusA plusA-comm plusAssoc zero f = J> refl
sum-comm' {A = A} plusA plusA-comm plusAssoc (suc k) f =
  J> f1' k f plusA plusAssoc k
      {p = 0 , refl} {q = +-comm (suc k) zero} {r = 0 , refl}
    ∙ plusA-comm _ _
    ∙ cong₂ plusA ((sum-comm' {A = A ∘ suc} plusA plusA-comm plusAssoc k
                              (λ n p → f (suc n) (suc-≤-suc p))
                              (λ n p → f (suc (k ∸ n)) (suc-≤-suc (flipFin' k (n , p) .snd)))
                              refl
                 ∙ cong (λ s → sum-helper≤ k s plusA k (0 , (λ i → k)))
                        (funExt (λ n → funExt λ p
                          → cong (λ x → f (fst x) (snd x))
                            (Σ≡Prop (λ _ → Cubical.Data.Nat.Order.isProp≤)
                              ((cong suc (cong (_∸ n) (sym (snd p))
                                ∙ +∸ (fst p) n)
                              ∙ sym (+∸ (suc (fst p)) n))
                             ∙ cong (_∸ n) (cong suc (snd p)))))))
                 ∙ sum-helper≤-suc k (λ n p → f (suc k ∸ n)
                  (flipFin' (suc k) (n , p) .snd)) plusA k (0 , refl))
        (cong (λ x → f (fst x) (snd x))
        (Σ≡Prop (λ _ → Cubical.Data.Nat.Order.isProp≤) (sym (n∸n k))) )

multᵣΠ' : ∀ {ℓ} (A : ℕ → Pointed ℓ)
          (mult : (n m : ℕ) → A n .fst → A m .fst → A (n + m) .fst)
       → (k : ℕ) (a : A k .fst) (f : (n : ℕ) → A n .fst)
       → ((n : ℕ) → A n .fst)
multᵣΠ' A mult k a f n with (Dichotomyℕ k n)
... | inl x = subst (fst ∘ A) (snd x) (mult _ _ (f (fst x)) a)
... | inr x = snd (A n)

-- multᵣΠ'Distr : (A : ℕ → Pointed₀)
--   → (plusA : {n : ℕ} → A n .fst → A n .fst → A n .fst)
--   → (plusA-comm : {n : ℕ} → (x y : A n .fst) → plusA x y ≡ plusA y x)
--   → (plusAssoc : {n : ℕ} (x y z : A n .fst) → plusA x (plusA y z) ≡ plusA (plusA x y) z)
--   → (mult : (n m : ℕ) → A n .fst → A m .fst → A (n + m) .fst)
--   → (multAssoc : (n m k : ℕ) (x : A n .fst) (y : A m .fst) (z : A k .fst)
--        → PathP (λ i → fst (A (+-assoc n m k i)))
--                 (mult n (m + k) x (mult m k y z))
--                 (mult (n + m) k (mult n m x y) z))
--   → ((n m : ℕ) (x : A n .fst) (y : A m .fst)
--       → PathP (λ i → A (+-comm n m i) .fst) (mult n m x y) (mult m n y x))
--   → (f : (n : ℕ) → A n .fst)
--   → (r : ℕ) (s : A r .fst)
--   → (k : ℕ) → sum≤ {A = fst (A k)} k (λ m as → subst (fst ∘ A) (as .snd) {!!} -- multᵣΠ' A mult r s f ?
--        ) plusA
--                ≡ {!!} -- sum≤ {A = fst ∘ A} plusA mult {!!} {!g!} {!!} ≡ {!!}
-- multᵣΠ'Distr = {!!}

sum-comm : {A : ℕ → Type}
  → (plusA : {n : ℕ} → A n → A n → A n)
  → (plusA-comm : {n : ℕ} → (x y : A n) → plusA x y ≡ plusA y x)
  → (plusAssoc : {n : ℕ} (x y z : A n) → plusA x (plusA y z) ≡ plusA (plusA x y) z)
  → (mult : (n m : ℕ) → A n → A m → A (n + m))
  → ((n m : ℕ) (x : A n) (y : A m)
      → PathP (λ i → A (+-comm n m i)) (mult n m x y) (mult m n y x))
  → (f g : (n : ℕ) → A n)
  → (k : ℕ) → sum plusA mult f g k ≡ sum plusA mult g f k
sum-comm {A = A} plusA plusA-comm plusAssoc mult commMult f g k =
  sum-comm' {A = A} plusA plusA-comm plusAssoc
     k ((λ p r → subst A (snd r) (mult (fst r) p (f (fst r)) (g p))))
       (λ p r → subst A (snd r) (mult (fst r) p (g (fst r)) (f p)))
       (funExt (λ n → funExt λ p
         → cong (subst A (snd (flipFin' k (n , p) .snd)))
                 (sym (fromPathP (commMult (k ∸ n) (fst (flipFin' k (n , p) .snd))
                   (g (k ∸ n)) (f (fst (flipFin' k (n , p) .snd)))))
                ∙ cong (subst A (+-comm (k ∸ n) (fst (flipFin' k (n , p) .snd))))
                       (sym (fromPathP λ i → mult (lem₁ n p i)
                                                   (lem₂ n p i)
                                                   (g (lem₁ n p i))
                                                   (f (lem₂ n p i)))))
               ∙ substLem _ _ _ _ _ _ _ _ (mult (fst p) n (g (fst p)) (f n))))
  where
  substLem : ∀ (a b : ℕ) (p : a ≡ b) (c : ℕ) (q : b ≡ c)
    (d : ℕ) (r : c ≡ d) (s : a ≡ d) (a : A a)
      → subst A r (subst A q (subst A p a)) ≡ subst A s a 
  substLem a = J> J> J> λ s a → transportRefl _ ∙ transportRefl _
    ∙ λ i → subst A (isSetℕ _ _ refl s i) a
  module _ (n : ℕ) (p : n ≤ k) where
    lem₁ : fst p ≡ k ∸ n
    lem₁ = (sym (+∸ (fst p) n) ∙ (cong (_∸ n) (snd p)))

    lem₂ : n ≡ (fst (flipFin' k (n , p) .snd))
    lem₂ = cong fst (Cubical.Data.Nat.Order.isProp≤
             (n , cong (n +_) (cong (_∸ n) (sym (snd p)))
                ∙ (cong (n +_)
                    (+∸ (fst p) n)
                ∙ +-comm n (fst p))
                ∙ snd p)
             (flipFin' k (n , p) .snd))

∑Π : ∀ {ℓ} {A : ℕ → Type ℓ}
  (plusA : {n : ℕ} → A n → A n → A n)
  (mult : (n m : ℕ) → A n → A m → A (n + m))
  (f g : (n : ℕ) → A n)
  (k : ℕ) → A k
∑Π plusA mult f g zero = mult zero zero (f zero) (g zero)
∑Π {A = A} plusA mult f g (suc k) =
  plusA (plusA (mult zero (suc k) (f zero) (g (suc k)))
               (mult zero (suc k) (g zero) (f (suc k))))
        (∑Π {A = A ∘ suc} plusA {!!} {!f!} {!!} k)

sum'Distr' : {!!}
sum'Distr' = {!!}

sum'Distr : ∀ {ℓ} {A : ℕ → Type ℓ} {B : ℕ → Type ℓ}
  (plusA : {n : ℕ} → A n → A n → A n)
  (mult : (n m : ℕ) → A n → B m → A (n + m))
  (multDistr : (n m : ℕ) (x y : A n) (z : B m) → mult n m (plusA x y) z ≡ plusA (mult n m x z) (mult n m y z))
  (f : (n : ℕ) → A n) (g : (n : ℕ) → B n)
  (assoc' : (n l : ℕ) (z : B l)
    → PathP (λ i → A (+-comm (suc n) l i))
             (mult (suc n) l (mult zero (suc n) (f zero) (g (suc n))) z)
             (mult l (suc n) (mult zero l (f zero) z) (g (suc n))))
  (t : ℕ) (h : B t)
  → (k : ℕ) → mult _ _ (sum' {A = A} plusA mult f g k) h
              ≡ sum' plusA (λ n m x y → subst A (sym (+-assoc n t m) ∙∙ cong (n +_) (+-comm t m) ∙∙ +-assoc n m t)
                           (mult _ _ x y)) (λ n → mult _ _ (f n) h) g k
sum'Distr plusA mult multDistr f g assoc' t h zero = {!!}
sum'Distr {A = A} {B = B} plusA mult multDistr f g assoc' t h (suc k) =
    multDistr (suc k) t _ _ h
  ∙ cong₂ plusA (sum'Distr {A = A ∘ suc} plusA
                (mult ∘ suc) (multDistr ∘ suc) (f ∘ suc) g (λ n l z → {!assoc' n (suc l) !}) t h k)
          {!mult !}
          {- (sym (cong (λ s → subst A s (mult t (suc k) (mult zero t (f zero) h) (g (suc k))))
                     (isSetℕ _ _ _ _)
                    ∙ fromPathP λ i → assoc' k t h (~ i)))
                    -}
  where
  help : (n l : ℕ) (z : B l)
    → (mult (suc (suc n)) l
       (mult zero (suc (suc n)) (f zero) (g (suc (suc n)))) z)
    ≡ {!assoc' (suc n) l z!}
  help = {!!}

sum'-sndLast : ∀ {ℓ} (A B : ℕ → Pointed ℓ)
  (plusA : {n : ℕ} → A n .fst → A n .fst → A n .fst)
  (plusB : {n : ℕ} → B n .fst → B n .fst → B n .fst)
  (mult : (n m : ℕ) → A n .fst → B m .fst → A (n + m) .fst)
  (mult-assoc₁ : {!!})
  (mult-distr : (n m : ℕ) (x : A n .fst) (y z : B m .fst)
    → mult n m x (plusB y z) ≡ plusA (mult n m x y) (mult n m x z))
  (n : ℕ)
  (f : (n : ℕ) → A n .fst) (g : Π' B (suc n))
  → mult 1 n (f 1) {!sum' plusB ?!} -- (sum' plusA mult f ? n)
   ≡ sum' plusA (λ n → mult (suc n)) (λ x → mult 1 x {!f x!} {!!}) (g .fst) n
sum'-sndLast A B plusA plusB mult mult-assoc mult-distr zero f g =
  {!(λ n → mult 1 n (f 1) (f n))!} -- mult-assoc 1 zero zero (f 1) (f 0) (g .fst 0)
sum'-sndLast A B plusA plusB mult mult-assoc mult-distr (suc n) f g = {!!}
{-
    mult-distr 1 (suc n) (f 1) (sum' plusA (λ n₁ → mult (suc n₁)) (λ x → f (suc x))
        (Π'↓₁ (suc n) A g) n) (mult zero (suc n) (f zero) (Π'↓₁ (suc n) A g (suc n)))
  ∙ cong₂ plusA
      {!sum'-sndLast A plusA mult mult-assoc mult-distr n f ?!}
      ({!!} -- (mult-assoc 1 zero (suc n) (f 1) (f zero) (Π'↓₁ (suc n) A g (suc n))
      ∙ help)
    where
    help : mult 1 (suc n) (mult 1 zero (f 1) (f zero)) (Π'↓₁ (suc n) A g (suc n))
      ≡ mult 1 (suc n) (mult 1 zero (f 1) (f zero)) (g .fst (suc n))
    help with (Dichotomyℕ (suc n) (suc n))
    ... | inl x = refl
    ... | inr x = ⊥.rec (¬m<m x)
-}
sum'alt : ∀ {ℓ} {A : ℕ → Type ℓ} {B : ℕ → Type ℓ}
  (plusB : {n : ℕ} → B n → B n → B n)
  (mult : (n m : ℕ) → A n → B m → B (n + m))
  (f : (n : ℕ) → A n) (g : (n : ℕ) → B n)
  → (k : ℕ) → B k
sum'alt plus mult f g zero = mult zero zero (f zero) (g zero)
sum'alt {A = A} {B = B} _+B_ mult f g (suc k) =
  sum'alt {A = A} {B = B ∘ suc} _+B_ {!λ n m x y → ? ?!} {!!} {!!} k
  +B subst (B ∘ suc) (+-comm k zero)
     (mult (suc k) zero
           (f (suc k))
           (g zero))



sum'0l : ∀ {ℓ} {A : ℕ → Type ℓ} {B : ℕ → Type ℓ}
  (plusA : {n : ℕ} → A n → A n → A n)
  (mult : (n m : ℕ) → A n → B m → A (n + m))
  (g : (n : ℕ) → B n)
  (0A : (n : ℕ) → A n)
  (rid : (n : ℕ) → plusA (0A n) (0A n) ≡ 0A n)
  (multR : (n m : ℕ) (y : B m) → mult n m (0A n) y ≡ 0A (n + m))
  (k : ℕ) → sum' plusA mult 0A g k ≡ 0A k
sum'0l plus mult g 0A rid multR zero = multR zero zero (g zero)
sum'0l plus mult g 0A rid multR (suc k) =
  cong₂ plus (sum'0l plus (mult ∘ suc) g (0A ∘ suc) (rid ∘ suc) (multR ∘ suc) k)
             (multR zero (suc k) (g (suc k)))
  ∙ rid (suc k)

sum'0 : ∀ {ℓ} {A : ℕ → Type ℓ} {B : ℕ → Type ℓ}
  (plusA : {n : ℕ} → A n → A n → A n)
  (mult : (n m : ℕ) → A n → B m → A (n + m))
  (f : (n : ℕ) → A n) (g : (n : ℕ) → B n)
  (0A : (n : ℕ) → A n) (0B : (n : ℕ) → B n)
  (rid : (n : ℕ) → plusA (0A n) (0A n) ≡ 0A n)
  (multL : (n m : ℕ) (x : A n) → mult n m x (0B m) ≡ 0A (n + m))
  (multR : (n m : ℕ) (y : B m) → mult n m (0A n) y ≡ 0A (n + m))
  (n m : ℕ)
  → ((k : ℕ) → f (k + n) ≡ 0A (k + n))
  → ((k : ℕ) → g (k + m) ≡ 0B (k + m) )
  → (k : ℕ) → sum' plusA mult f g (k + (n + m)) ≡ 0A (k + (n + m))
sum'0 {A = A} {B = B} _+A_ mult f g 0A 0B rid multL multR zero m fl gl zero =
  (λ i → sum' _+A_ mult (λ n → subst (λ n → f n ≡ 0A n) (+-comm n zero) (fl n) i) g m)
  ∙ sum'0l _+A_ mult g 0A rid multR m
sum'0 {A = A} {B = B} _+A_ mult f g 0A 0B rid multL multR (suc n) m fl gl zero =
  cong₂ _+A_ (sum'0 _+A_ (λ n₁ → mult (suc n₁)) (f ∘ suc) g
               (0A ∘ suc) 0B (rid ∘ suc) (multL ∘ suc) (multR ∘ suc) n m
                    (λ k → subst (λ n → f n ≡ 0A n) (+-suc k n) (fl k)) gl zero)
             (cong (mult zero (suc (n + m)) (f zero)) (gl (suc n))
             ∙ multL zero (suc (n + m)) (f zero))
  ∙ rid _
sum'0 {A = A} {B = B} _+A_ mult f g 0A 0B rid multL multR n m fl gl (suc k) =
  cong₂ _+A_ (sum'0 _+A_ (λ n₁ → mult (suc n₁)) (f ∘ suc) g (0A ∘ suc) 0B
               (rid ∘ suc) (multL ∘ suc) (multR ∘ suc) n m (fl ∘ suc) gl k)
       (cong (mult zero (suc (k + (n + m))) (f zero))
             (subst (λ n → g n ≡ 0B n) (cong suc (sym (+-assoc k n m))) (gl (suc k + n)))
             ∙ multL _ _ (f zero) )
     ∙ rid _

sum''0-bas : ∀ {ℓ} {A : ℕ → Type ℓ} {B : ℕ → Type ℓ}
  (plusA : {n : ℕ} → A n → A n → A n)
  (mult : (n m : ℕ) → A n → B m → A (n + m))
  (f : (n : ℕ) → A n) (g : (n : ℕ) → B n)
  (0A : (n : ℕ) → A n) (0B : (n : ℕ) → B n)
  (rid : (n : ℕ) → plusA (0A n) (0A n) ≡ 0A n)
  (multL : (n m : ℕ) (x : A n) → mult n m x (0B m) ≡ 0A (n + m))
  (multR : (n m : ℕ) (y : B m) → mult n m (0A n) y ≡ 0A (n + m))
  (n m : ℕ)
  → ((k : ℕ) → f (k + n) ≡ 0A (k + n))
  → ((k : ℕ) → g (suc k + m) ≡ 0B (suc k + m) )
  → sum' plusA mult f g (n + m) ≡ 0A (n + m)
sum''0-bas plusA mult f g 0A 0B rid mulL multR zero m fl gl =
  cong (λ f → sum' plusA mult f g m)
    (funExt (λ x → subst (λ n → f n ≡ 0A n) (+-comm x zero) (fl x)))
  ∙ (sum'0l plusA mult g 0A rid multR m)
sum''0-bas plusA mult f g 0A 0B rid mulL multR (suc n) m fl gl =
    cong₂ plusA (sum''0-bas plusA (mult ∘ suc) (f ∘ suc) g
                   (0A ∘ suc) 0B (λ _ → rid _) (mulL ∘ suc) (multR ∘ suc) n m
                     (λ k → subst (λ n → f n ≡ 0A n) (+-suc k n) (fl k) ) gl)
                (cong (mult zero (suc (n + m)) (f zero)) (gl n) ∙ mulL _ _ (f zero))
  ∙ rid _

sum''0 : ∀ {ℓ} {A : ℕ → Type ℓ} {B : ℕ → Type ℓ}
  (plusA : {n : ℕ} → A n → A n → A n)
  (mult : (n m : ℕ) → A n → B m → A (n + m))
  (f : (n : ℕ) → A n) (g : (n : ℕ) → B n)
  (0A : (n : ℕ) → A n) (0B : (n : ℕ) → B n)
  (rid : (n : ℕ) → plusA (0A n) (0A n) ≡ 0A n)
  (multL : (n m : ℕ) (x : A n) → mult n m x (0B m) ≡ 0A (n + m))
  (multR : (n m : ℕ) (y : B m) → mult n m (0A n) y ≡ 0A (n + m))
  (n m : ℕ)
  → ((k : ℕ) → f (suc k + n) ≡ 0A (suc k + n))
  → ((k : ℕ) → g (suc k + m) ≡ 0B (suc k + m) )
  → (k : ℕ) → sum' plusA mult f g (suc k + (n + m)) ≡ 0A (suc k + (n + m))
sum''0 {A = A} {B = B} _+A_ mult f g 0A 0B rid multL multR n m fl gl zero =
  cong₂ _+A_ (sum''0-bas _+A_ (λ n₁ → mult (suc n₁)) (λ x → f (suc x))  g (0A ∘ suc) 0B
                (rid ∘ suc) (multL ∘ suc) (multR ∘ suc) n m fl gl)
             (cong (mult zero (suc (n + m)) (f zero)) (gl n)
             ∙ multL zero (suc (n + m)) (f zero))
  ∙ rid _
sum''0 {A = A} {B = B} _+A_ mult f g 0A 0B rid multL multR n m fl gl (suc k) =
  cong₂ _+A_ (sum''0 _+A_ (λ n₁ → mult (suc n₁)) (f ∘ suc) g (0A ∘ suc) 0B
               (rid ∘ suc) (multL ∘ suc) (multR ∘ suc) n m (fl ∘ suc) gl k)
       (cong (mult zero (suc (suc (k + (n + m)))) (f zero))
         (subst (λ n → g (suc (suc n)) ≡ 0B (suc (suc n)))
                (sym (+-assoc k n m)) (gl (suc (k + n))))
         ∙ multL _ _ _)
     ∙ rid _

pick-only : ∀ {ℓ} (n : ℕ) (A : ℕ → Pointed ℓ)
  → A n .fst → Π' A n
fst (pick-only n A x) k with (Cubical.Data.Nat.Order._≟_ k n)
... | lt x₁ = A k .snd
... | Trichotomy.eq x₁ = subst (fst ∘ A) (sym x₁) x
... | gt x₁ = A k .snd
snd (pick-only n A x) k with (Cubical.Data.Nat.Order._≟_ (suc k + n) n)
... | lt x₁ = refl
... | Trichotomy.eq x₁ = ⊥.rec (¬m<m (k , +-suc k n ∙ x₁))
... | gt x₁ = refl

{-
sum'0
-}

sumπ↓ : ∀ {ℓ} (n m : ℕ) (A B : ℕ → Pointed ℓ) (k : ℕ) (r : k ≤ n + m)
  (plusA : {n : ℕ} → A n .fst → A n .fst → A n .fst)
  (mult : (n m : ℕ) → A n .fst → B m .fst → A (n + m) .fst)
  (multL : (n m : ℕ) (x : A n .fst) → mult n m x (snd (B m)) ≡ snd (A (n + m)))
  (multR : (n m : ℕ) (y : B m .fst) → mult n m (snd (A n)) y ≡ snd (A (n + m)))
  (plusA-rid : {n : ℕ} (x : A n .fst) → plusA x (A n .snd) ≡ x)
  (plusA-assoc : {n : ℕ} (x y z : A n .fst) → plusA x (plusA y z) ≡ plusA (plusA x y) z)
  (plusA-comm : {n : ℕ} → (x y : A n .fst) → plusA x y ≡ plusA y x)
  (f :  Π' A (suc n)) (g : Π' B m)
  → plusA (sum' plusA mult (fst f) (fst g) k)
           (pick-only (suc (n + m)) A (mult _ _ (f .fst (suc n)) (g .fst m)) .fst k)
   ≡ sum' plusA mult (Π'↓₁ n A f) (fst g) k
sumπ↓ n m A B zero r plusA mult multL multR plusA-rid plusA-assoc plusA-comm f g with (Dichotomyℕ 0 n)
... | inl x = plusA-rid _ -- refl
... | inr x = ⊥.rec (⊥.rec (snotz (sym (+-suc (fst x) n) ∙ x .snd)))
sumπ↓ zero zero A B (suc k) r plusA mult multL multR plusA-rid plusA-assoc plusA-comm f g =
  ⊥.rec (snotz (sym (+-suc (fst r) k) ∙ r .snd))
sumπ↓ zero (suc m) A B (suc k) r plusA mult multL multR plusA-rid plusA-assoc plusA-comm f g =
  {!!}
{-
  cong₂ plusA (sumπ↓ zero (suc m) (A ∘ suc) B k (≤-trans (1 , refl) r) plusA (λ n → mult (suc n))
                          (multL ∘ suc) (multR ∘ suc) plusA-rid plusA-assoc
                            ((λ x → fst f (suc x)) , (λ k → snd f (suc k))) g
              ∙ {!!})
              refl
              -}
  where
  help : (x : ℕ) →
      Π'↓₁ zero (λ x₁ → A (suc x₁)) ((λ n → fst f (suc n)) , (λ k₂ → snd f (suc k₂))) x
    ≡ Π'↓₁ zero A f (suc x)
  help x with (Dichotomyℕ x 0)
  ... | inl (zero , t) = {!!}
  ... | inl (suc x₁ , t) = {!!}
  ... | inr x₁ = refl
sumπ↓ (suc n) m A B (suc k) r plusA mult multL multR plusA-rid plusA-assoc plusA-comm f g =
  sym (plusA-assoc _ _ _)
  ∙ cong₂ plusA refl (plusA-comm _ _ ∙ refl)
  ∙ plusA-assoc _ _ _
  ∙ cong₂ plusA {!!} refl
  where
  cool : plusA
      (sum' plusA (λ n₁ → mult (suc n₁)) (λ x → fst f (suc x)) (fst g) k)
      (fst
       (pick-only (suc (suc (n + m))) A
        (mult (suc (suc n)) m (f .fst (suc (suc n))) (g .fst m)))
       (suc k)) ≡ sum' plusA (λ n₁ → mult (suc n₁)) (λ x → Π'↓₁ (suc n) A f (suc x)) (fst g) k
  cool with (k Cubical.Data.Nat.Order.≟ suc (n + m))
  ... | lt x = {!!}
  ... | Trichotomy.eq x = {!!}
  ... | gt x = {!!}
  {-
  cong₂ plusA (sumπ↓ n m (A ∘ suc) B k
    {!!}
                 plusA (λ n₁ → mult (suc n₁))
                 (multL ∘ suc)
                 (multR ∘ suc)
                 plusA-rid
                 plusA-assoc
                 ((λ x → fst f (suc x)) , (λ k → subst (λ n → fst f n ≡ snd (A n)) (cong suc (+-suc k (suc n))) (snd f k))) g
             ∙ cong (λ t → sum' plusA (λ n₁ → mult (suc n₁)) t
      (fst g) k) (funExt {!!})) refl
      -}
{-
  cong₂ plusA (sumπ↓ n m (A ∘ suc) B k (≤-trans (1 , refl) r) plusA (mult ∘ suc)
              (multL ∘ suc) (multR ∘ suc) plusA-rid
              plusA-assoc ((λ x → fst f (suc x)) , snd f ∘ suc) g)
              refl
      ∙ cong₂ plusA {!!}
                    (sym (cong (λ t → mult zero (suc k) t (fst g (suc k))) help))
  where
  help : Π'↓₁ n A f zero ≡ fst f zero
  help with (Dichotomyℕ 0 n)
  ... | inl x = refl
  ... | inr x = ⊥.rec (snotz (sym (+-suc (fst x) n) ∙ snd x))

  help2 : (x : ℕ) →
      Π'↓₁ n (λ x₁ → A (suc x₁))
      ((λ x₁ → fst f (suc x₁)) , (λ x₁ → snd f (suc x₁))) x
      ≡ Π'↓₁ n A f (suc x)
  help2 x with (Dichotomyℕ x n)
  ... | inl x₁ = help3
    where
    help3 : fst f (suc x)  ≡ Π'↓₁ n A f (suc x)
    help3 with (Dichotomyℕ (suc x) n )
    ... | inl p = refl
    ... | inr (zero , p) = {!r .snd  ∙ (cong (_+ m) (cong predℕ p))!}
    ... | inr (suc t , p) = {!snd f 0 --  snd p -- cong suc (x₁ .snd) -- snd p -- -- p .snd!}
  ... | inr x₁ = help3
    where
    help3 : snd (A (suc x)) ≡ Π'↓₁ n A f (suc x)
    help3 with (Dichotomyℕ (suc x) n )
    ... | inl x = ⊥.rec (¬m<m (_
      , sym (+-assoc (suc (fst x₁)) (fst x) _)
      ∙ sym (+-suc (fst x₁) (fst x + suc _))
      ∙ cong (fst x₁ +_) (cong suc (snd x)) ∙ x₁ .snd))
    ... | inr x = refl
Π↓-mult : ∀ {ℓ} (n m : ℕ) (A B : ℕ → Pointed ℓ) (k : ℕ)
  (plusA : {n : ℕ} → A n .fst → A n .fst → A n .fst)
  (mult : (n m : ℕ) → A n .fst → B m .fst → A (n + m) .fst)
  (multL : (n m : ℕ) (x : A n .fst) → mult n m x (snd (B m)) ≡ snd (A (n + m)))
  (multR : (n m : ℕ) (y : B m .fst) → mult n m (snd (A n)) y ≡ snd (A (n + m)))
  (plusA-rid : {n : ℕ} (x : A n .fst) → plusA x (A n .snd) ≡ x)
  (plusA-assoc : {n : ℕ} (x y z : A n .fst) → plusA x (plusA y z) ≡ plusA (plusA x y) z)
  (f :  Π' A (suc n)) (g : Π' B m)
  {t : _}
  → Π'↓ (n + m) A ((sum' plusA mult (fst f) (fst g)) , t) .fst k
   ≡ sum' plusA mult (Π'↓ _ A f .fst) (fst g) k
Π↓-mult n m A B k plusA mult multL multR plusA-rid plusA-assoc f g {t} with (Dichotomyℕ k (n + m))
... | inl x = {!x!}
  where
  help : sum' plusA mult (fst f) (fst g) k ≡ sum' plusA mult (Π'↓₁ n A f) (fst g) k
  help = {!Π'↓₁ n A f!}
... | inr x =
  sym (subst (λ as → sum' plusA mult (Π'↓₁ n A f) (fst g) as ≡ snd (A as))
                (sym (+-suc (fst x) (n + m)) ∙ snd x) -- p
                (sum''0 plusA mult (Π'↓ _ A f .fst) (fst g) (snd ∘ A) (snd ∘ B)
                  (λ _ → plusA-rid _)
                  multL
                  multR
                  n m
                  (Π'↓₂ n A f )
                  (snd g)
                  (fst x)))
-}

Π↓-mult : ∀ {ℓ} (n m : ℕ) (A B : ℕ → Pointed ℓ) (k : ℕ)
  (plusA : {n : ℕ} → A n .fst → A n .fst → A n .fst)
  (mult : (n m : ℕ) → A n .fst → B m .fst → A (n + m) .fst)
  (plusA-rid : {n : ℕ} (x : A n .fst) → plusA x (A n .snd) ≡ x)
  (plusA-assoc : {n : ℕ} (x y z : A n .fst) → plusA x (plusA y z) ≡ plusA (plusA x y) z)
  (f :  Π' A (suc n)) (g : (n : ℕ) → B n .fst)
  {t : _}
  → Π'↓ (n + m) A ((sum' plusA mult (fst f) g) , t) .fst k
   ≡ plusA
      (sum' plusA mult (Π'↓ _ A f .fst) g k)
      (pick-only (suc n + m) A (mult (suc n) m (f .fst (suc n)) (g m)) .fst k)
Π↓-mult n m A B zero plusA mult plusA-rid plusA-assoc f g {t} with (Dichotomyℕ 0 (n + m))
... | inl p1 = lem1
 where
 lem1 : mult zero zero (fst f zero) (g zero) ≡ plusA (mult 0 0 (Π'↓₁ n A f 0 ) (g 0)) (A 0 .snd)
 lem1 with (Dichotomyℕ 0 n)
 ... | inl x = sym (plusA-rid (mult 0 0 (fst f 0) (g 0)))
 ... | inr x = ⊥.rec (snotz (sym (+-suc (fst x) n) ∙ snd x))
... | inr x = ⊥.rec (snotz (sym (+-suc (fst x) (n + m)) ∙ snd x))
Π↓-mult n m A B (suc k) plusA mult plusA-rid plusA-assoc f g {t} with (Dichotomyℕ 0 n)
... | inl x = help
  where

  help : (Π'↓₁ (n + m) A (sum' plusA mult (fst f) g , t) (suc k))
      ≡ plusA
         (plusA (sum' plusA (λ n₁ → mult (suc n₁)) (λ x₂ →  Π'↓₁ n A f (suc x₂)) g k)
                (mult 0 (suc k) (fst f 0) (g (suc k))))
      (fst (pick-only (suc (n + m)) A (mult (suc n) m (f .fst (suc n)) (g m))) (suc k))
  help with (Dichotomyℕ (suc k) (n + m))
  ... | inl x = main'
    where
    main' : plusA (sum' plusA (λ n₁ → mult (suc n₁)) (λ x₂ → fst f (suc x₂)) g k)
                   (mult zero (suc k) (fst f zero) (g (suc k)))
      ≡ plusA
         (plusA (sum' plusA (λ n₁ → mult (suc n₁)) (λ x₂ →  Π'↓₁ n A f (suc x₂)) g k)
                (mult 0 (suc k) (fst f 0) (g (suc k))))
      (fst (pick-only (suc (n + m)) A (mult (suc n) m (f .fst (suc n)) (g m))) (suc k))
    main' with (k Cubical.Data.Nat.Order.≟ (n + m))
    ... | lt p = cong (λ z → plusA z (mult 0 (suc k) (fst f 0) (g (suc k))))
                      {!!}
                    ∙ sym (plusA-rid _)
    ... | Trichotomy.eq p = ⊥.rec (¬m<m (fst x , (snd x ∙ sym p)))
    ... | gt p = ⊥.rec (¬m<m (<-trans p x))
  ... | inr x = main
    where
    main : snd (A (suc k)) ≡
      plusA (plusA
       (sum' plusA (λ n₁ → mult (suc n₁))
        (λ x₂ → Π'↓₁ n A f (suc x₂)) g k)
       (mult 0 (suc k) (fst f 0) (g (suc k))))
      (fst
       (pick-only (suc (n + m)) A (mult (suc n) m (f .fst (suc n)) (g m)))
       (suc k))
    main with (k Cubical.Data.Nat.Order.≟ (n + m))
    ... | lt p = {!!}
    ... | Trichotomy.eq p = {!!}
    ... | gt p = {!<-trans !}
... | inr x = ⊥.rec (snotz (sym (+-suc (fst x) n) ∙ snd x))

{-
Π↓-mult n m A B zero plusA mult f g {t = t} with (Dichotomyℕ 0 (n + m))
... | inl x = ?
  where
  help : mult zero zero (fst f zero) (g zero)
       ≡ mult 0 0 (Π'↓₁ n A f 0) (g 0)
  help with (Dichotomyℕ 0 n)
  ... | inl x = refl
  ... | inr x = ⊥.rec (⊥.rec (snotz (sym (+-suc (fst x) n) ∙ snd x)))
... | inr x = ⊥.rec (snotz (sym (+-suc (fst x) (n + m)) ∙ snd x))
Π↓-mult n m A B (suc k) plusA mult f g {t = t} with (Dichotomyℕ 0 n)
... | inl x = lem
  where
  lem : Π'↓₁ (n + m) A (sum' plusA mult (fst f) g , t) (suc k)
      ≡ plusA
      (sum' plusA (λ n₁ → mult (suc n₁))
       (λ x₁ → Π'↓₁ n A f (suc x₁))
       g k)
      (mult 0 (suc k) (fst f 0) (g (suc k)))
  lem with (Dichotomyℕ (suc k) (n + m))
  ... | inl x = cong₂ plusA {!!} refl
    where
    cool : (k : ℕ) → Π'↓₁ n A f (suc k) ≡ f .fst (suc k)
    cool k with (Dichotomyℕ (suc k) n)
    ... | inl x = refl
    ... | inr (zero , p) = {! snd f zero!}
    ... | inr (suc x' , p) = {!!}
  ... | inr x = {!!}
... | inr x = ⊥.rec (snotz (sym (+-suc (fst x) n) ∙ snd x))
-}


+Π' : (n : ℕ) (f g : Π' (EM∙ ℤ/2) n) → Π' (EM∙ ℤ/2) n
fst (+Π' n f g) x = fst f x +ₖ fst g x
snd (+Π' n f g) k = cong₂ _+ₖ_ (snd f k) (snd g k) ∙ rUnitₖ (suc (k + n)) (0ₖ _)

mult⌣ : (n m : ℕ) (f : Π' (EM∙ ℤ/2) n) (g : Π' (EM∙ ℤ/2) m) → Π' (EM∙ ℤ/2) (n + m)
fst (mult⌣ n m f g) = sum' _+ₖ_ ⌣ₖ₂' (fst f) (fst g)
snd (mult⌣ n m f g) k =
  sum''0 _+ₖ_ ⌣ₖ₂' (fst f) (fst g) 0ₖ 0ₖ
  (λ n → rUnitₖ n (0ₖ n))
  (λ n m x → cong (subst (EM ℤ/2) (+'≡+ n m)) (⌣ₖ-0ₖ n m x)
            ∙ subst-EM∙ (+'≡+ n m) .snd)
  ((λ n m x → cong (subst (EM ℤ/2) (+'≡+ n m)) (0ₖ-⌣ₖ n m x)
            ∙ subst-EM∙ (+'≡+ n m) .snd))
  n m (snd f) (snd g) k

mult⌣₀ₗ-fst : (m : ℕ) (f : Π' (EM∙ ℤ/2) zero) (g : Π' (EM∙ ℤ/2) m) (k : ℕ)
  → mult⌣ 0 m f g .fst k ≡ ⌣ₖ₂ {n = zero} {k} (fst f zero) (fst g k)
mult⌣₀ₗ-fst m f g zero = transportRefl _
mult⌣₀ₗ-fst m f g (suc k) =
     cong₂ _+ₖ_ ((λ i → sum' _+ₖ_ (λ n → ⌣ₖ₂' (suc n)) (help i) (fst g) k)
                 ∙ sum'0l _+ₖ_ (λ n → ⌣ₖ₂' (suc n)) (fst g) (0ₖ ∘ suc)
                      (λ k → rUnitₖ (suc k) (0ₖ (suc k)))
                      (λ n m y → cong (subst (EM ℤ/2) (+'≡+ (suc n) m))
                                    (0ₖ-⌣ₖ (suc n) m y)
                        ∙ subst-EM-0ₖ (+'≡+ (suc n) m) ) k)
                 (transportRefl (⌣ₖ₂ (fst f zero) (fst g (suc k))))
   ∙ lUnitₖ (suc k) (⌣ₖ₂ {n = zero} (fst f zero) (fst g (suc k)))
  where
  help : (f .fst ∘ suc) ≡ (λ n → 0ₖ (suc n))
  help = funExt λ s → subst (λ n → fst f n ≡ 0ₖ n) (cong suc (+-comm s zero)) (f .snd s)

mult⌣₀ₗ : (m : ℕ) (f : Π' (EM∙ ℤ/2) zero) (g : Π' (EM∙ ℤ/2) m)
  → mult⌣ 0 m f g ≡ ((λ n → ⌣ₖ₂ {n = zero} {n} (fst f zero) (fst g n))
                    , (λ k → cong (⌣ₖ₂ (fst f zero)) (snd g k)
                      ∙ ⌣ₖ-0ₖ zero (suc (k + m)) (fst f zero) ))
mult⌣₀ₗ n f g = Π'≡ (EM∙ ℤ/2) _ λ k _ → mult⌣₀ₗ-fst n f g k

module _ {ℓ} {A : ℕ → Type ℓ}
             (multA : (n m : ℕ) → A n → A m → A (n + m)) where
  multˣ₀ : (m : ℕ) → A zero → A ˣ m → A ˣ m
  multˣ₀ zero a x = multA zero zero a x
  multˣ₀ (suc m) a (x , y) = (multˣ₀ m a x) , (multA zero (suc m) a y)

  multˣ : (n m : ℕ) → A ˣ n → A ˣ m → A ˣ (n + m)
  multˣ zero = multˣ₀
  multˣ (suc n) m (x , a) y = (multˣ n m x y) , (multA (suc n) m a (lastˣ A m y))



  module _ (0A : (n : ℕ) → A n)
    (multA0ₗ : (n m : ℕ) (a : A m) → multA n m (0A n) a ≡ 0A (n + m)) where

    multˣAnnₗ : (n m : ℕ) (a : A ˣ m) → multˣ n m (0ˣ A 0A n) a ≡ 0ˣ A 0A (n + m)
    multˣAnnₗ zero zero a = multA0ₗ zero zero a
    multˣAnnₗ zero (suc m) a = ΣPathP ((multˣAnnₗ zero m (fst a)) , (multA0ₗ zero (suc m) (snd a)))
    multˣAnnₗ (suc n) m a = ΣPathP ((multˣAnnₗ n m a) , (multA0ₗ (suc n) m (lastˣ A m a)))

  module _ (1A : A 0)
    (multA1ₗ : (m : ℕ) (a : A m) → multA zero m 1A a ≡ a) where

    multˣIdL : (m : ℕ) (a : A ˣ m) → multˣ zero m 1A a ≡ a
    multˣIdL zero a = multA1ₗ zero a
    multˣIdL (suc m) a = ΣPathP (multˣIdL m (fst a) , multA1ₗ (suc m) (snd a))


0ₖ-⌣ₖ₂' : (n m : ℕ) → (y : EM ℤ/2 m) → ⌣ₖ₂' n m (0ₖ n) y ≡ 0ₖ (n + m)
0ₖ-⌣ₖ₂' n m y = cong (subst (EM ℤ/2) (+'≡+ n m)) (0ₖ-⌣ₖ n m y) ∙ subst-EM∙ (+'≡+ n m) .snd

multˣ⌣ : (n m : ℕ) → (EM ℤ/2) ˣ n → (EM ℤ/2) ˣ m → (EM ℤ/2) ˣ (n +' m)
multˣ⌣ n m x y =
  subst ((EM ℤ/2) ˣ_) (sym (+'≡+ n m))
    (multˣ ⌣ₖ₂' n m x y)

{-RP→EM-ℤ/2-CharacIso-}

RP→EM-ℤ/2-CharacIso' : (n : ℕ)
  → Iso (EM ℤ/2 1 → EM ℤ/2 n)
         (Π' (EM∙ ℤ/2) n)
RP→EM-ℤ/2-CharacIso' zero = compIso RP→Charac₀ (invIso (Π'≅× zero (EM∙ ℤ/2)))
RP→EM-ℤ/2-CharacIso' (suc n) =
  compIso (EM→-charac {A = EM∙ ℤ/2 1} (suc n))
   (compIso Σ-swap-Iso
     (compIso (prodIso idIso (compIso (invIso (equivToIso (⌣RP∞''Equiv n)))
       (RP→EM-ℤ/2-CharacIso' n)))
         (invIso (Π'-ind n (EM∙ ℤ/2)))))

0ₖΠ' : (n : ℕ) → Π' (EM∙ ℤ/2) n
0ₖΠ' n = 0Π' n (EM∙ ℤ/2)

Π'↓∙ : (n : ℕ) → Π'↓ n (EM∙ ℤ/2) (0ₖΠ' (suc n)) ≡ 0ₖΠ' n
Π'↓∙ n = Π'≡ (EM∙ ℤ/2) n λ k _ → Π'↓₁∙ n (EM∙ ℤ/2) k

RP→EM-ℤ/2-CharacIso'inv∙ :  (n : ℕ)
  → Iso.inv (RP→EM-ℤ/2-CharacIso' n) (0ₖΠ' n) ≡ λ _ → 0ₖ n
RP→EM-ℤ/2-CharacIso'inv∙ zero = refl
RP→EM-ℤ/2-CharacIso'inv∙ (suc n) =
  funExt (λ x
    → rUnitₖ (suc n) (⌣RP∞''Equiv n .fst
         (inv (RP→EM-ℤ/2-CharacIso' n)
          (Π'↓ n (EM∙ ℤ/2) (0ₖΠ' (suc n)))) .fst x)
    ∙∙ cong (subst (EM ℤ/2) (+'-suc₁ n))
         (lem x)
    ∙∙ subst-EM-0ₖ (+'-suc₁ n))
  where
  lem : (x : EM ℤ/2 1)
    → ⌣ₖ₂ {n = 1} {m = n} x
           (inv (RP→EM-ℤ/2-CharacIso' n) (Π'↓ n (EM∙ ℤ/2) (0ₖΠ' (suc n))) x)
    ≡ 0ₖ (1 +' n)
  lem x =
      cong (⌣ₖ₂ {n = 1} {m = n} x)
          (funExt⁻ (cong (inv (RP→EM-ℤ/2-CharacIso' n)) (Π'↓∙ n)) x
        ∙ funExt⁻ (RP→EM-ℤ/2-CharacIso'inv∙ n) x)
    ∙ ⌣ₖ-0ₖ {G'' = ℤ/2Ring} 1 n x


RP→EM-ℤ/2-CharacIso'∙ : (n : ℕ) → Iso.fun (RP→EM-ℤ/2-CharacIso' n) (λ _ → 0ₖ n) ≡ ((λ n → 0ₖ n) , (λ _ → refl))
RP→EM-ℤ/2-CharacIso'∙ n = {!!}

RP→EM-ℤ/2-CharacIso-hom'+ : (n : ℕ) (x y : _)
  → Iso.inv (RP→EM-ℤ/2-CharacIso' n) (+Π' n x y)
   ≡ λ a → (Iso.inv (RP→EM-ℤ/2-CharacIso' n) x a) +ₖ (Iso.inv (RP→EM-ℤ/2-CharacIso' n) y a)
RP→EM-ℤ/2-CharacIso-hom'+ zero = λ _ _ → refl
RP→EM-ℤ/2-CharacIso-hom'+ (suc n) f g =
  funExt λ x → {!!}

expEM₁ : (x : EM ℤ/2 1) → (n : ℕ) → EM ℤ/2 n
expEM₁ x zero = fone
expEM₁ x (suc n) = ⌣ₖ₂' 1 n x (expEM₁ x n)

RP→EM-ℤ/2-CharacIso'-expl' : (n : ℕ) (f : _) (x : _)
  → Iso.inv (RP→EM-ℤ/2-CharacIso' n) f x
    ≡ sum {A = EM ℤ/2} _+ₖ_ ⌣ₖ₂' (expEM₁ x) (fst f) n
RP→EM-ℤ/2-CharacIso'-expl' zero f x = sym (1ₖ-⌣ₖ {G'' = ℤ/2Ring} zero (fst f zero))
  ∙ sym (transportRefl _)
  ∙ sym (transportRefl _)
RP→EM-ℤ/2-CharacIso'-expl' (suc n) f x =
  cong₂ _+ₖ_ (cong (subst (EM ℤ/2) (+'-suc₁ n))
               (λ j → ⌣[]ₖ-syntax ℤ/2Ring x (RP→EM-ℤ/2-CharacIso'-expl' n (Π'↓ n (EM∙ ℤ/2) f) x j))
    ∙ {!λ j → RP→EM-ℤ/2-CharacIso'-expl' n (Π'↓ n (EM∙ ℤ/2) f)!})
    (refl {x = (fst f (suc n))}
        ∙ (sym (1ₖ-⌣ₖ {G'' = ℤ/2Ring} (suc n) (fst f (suc n)))
        ∙ sym (transportRefl _))
        ∙ sym (transportRefl _))


-- RP→EM-ℤ/2-CharacIso'-expl : (n : ℕ) (f : _) (x : _)
--   → Iso.inv (RP→EM-ℤ/2-CharacIso' n) f x
--     ≡ sum' {A = EM ℤ/2} {B = EM ℤ/2} _+ₖ_ ⌣ₖ₂' (expEM₁ x)  (f .fst) n
-- RP→EM-ℤ/2-CharacIso'-expl zero f x =
--    sym (1ₖ-⌣ₖ {G'' = ℤ/2Ring} zero (fst f zero))
--     ∙ sym (transportRefl _)
-- RP→EM-ℤ/2-CharacIso'-expl (suc n) f x =
--     cong₂ _+ₖ_ (cong (λ z → ⌣RP∞''Equiv n .fst z .fst x)
--                  (funExt (RP→EM-ℤ/2-CharacIso'-expl n (Π'↓ n (EM∙ ℤ/2) f)))
--               ∙ (λ i → subst (EM ℤ/2) (+'-suc₁ n)
--                           (⌣ₖ₂ {n = 1} {m = n} x
--                                (sum' _+ₖ_ ⌣ₖ₂' (expEM₁ x) (Π'↓₁ n (EM∙ ℤ/2) f) n)))
--               ∙ {!!})
--                  (refl {x = fst f (suc n)}
--                  ∙ sym (1ₖ-⌣ₖ {G'' = ℤ/2Ring} (suc n) (fst f (suc n)))
--                  ∙ sym (transportRefl _))
--   ∙ refl

-- -- RP→EM-ℤ/2-CharacIso-hom' : (n m : ℕ) (x : _) (y : _)
-- --   → Iso.inv (RP→EM-ℤ/2-CharacIso' (n + m)) (mult⌣ n m x y)
-- --    ≡ λ a → ⌣ₖ₂' n m (Iso.inv (RP→EM-ℤ/2-CharacIso' n) x a)
-- --                      (Iso.inv (RP→EM-ℤ/2-CharacIso' m) y a)
-- -- RP→EM-ℤ/2-CharacIso-hom' zero m f g =
-- --     cong (inv (RP→EM-ℤ/2-CharacIso' m)) (mult⌣₀ₗ m f g)
-- --   ∙ funExt (help _ refl)
-- --   where
-- --   help : (t : ℤ/2 .fst) (r : fst f zero ≡ t) (x : EM ℤ/2 1)
-- --     → inv (RP→EM-ℤ/2-CharacIso' m) (mult⌣₀ₗ m f g i1) x
-- --     ≡ ⌣ₖ₂' zero m (fst f zero) (inv (RP→EM-ℤ/2-CharacIso' m) g x)
-- --   help = ℤ/2-elim
-- --     (λ r x → (funExt⁻ (cong (inv (RP→EM-ℤ/2-CharacIso' m))
-- --          (Π'≡ (EM∙ ℤ/2) _ λ k p
-- --            → cong (λ t → ⌣ₖ₂ {n = zero} {m = k} t (fst g k)) r
-- --             ∙ 0ₖ-⌣ₖ {G'' = ℤ/2Ring} zero k (fst g k))) x
-- --       ∙ funExt⁻ (RP→EM-ℤ/2-CharacIso'inv∙ m) x)
-- --       ∙ sym (subst-EM-0ₖ (+'≡+ zero m))
-- --       ∙ cong (subst (EM ℤ/2) (+'≡+ zero m))
-- --         (sym (0ₖ-⌣ₖ {G'' = ℤ/2Ring} zero m (inv (RP→EM-ℤ/2-CharacIso' m) g x))
-- --        ∙ cong (λ t → ⌣ₖ₂ {n = zero} {m = m} t (inv (RP→EM-ℤ/2-CharacIso' m) g x))
-- --               (sym r)))
-- --     λ r x → funExt⁻ (cong (inv (RP→EM-ℤ/2-CharacIso' m))
-- --               (Π'≡ (EM∙ ℤ/2) _ λ k _
-- --                 → cong (λ t → ⌣ₖ₂ {n = zero} {m = k} t (fst g k)) r
-- --                 ∙ 1ₖ-⌣ₖ {G'' = ℤ/2Ring} k (fst g k))) x
-- --       ∙ sym (transportRefl _) -- sym (subst-EM-0ₖ (+'≡+ zero m))
-- --       ∙ cong (subst (EM ℤ/2) (+'≡+ zero m))
-- --         (sym (1ₖ-⌣ₖ {G'' = ℤ/2Ring} m (inv (RP→EM-ℤ/2-CharacIso' m) g x))
-- --        ∙ cong (λ t → ⌣ₖ₂ {n = zero} {m = m} t (inv (RP→EM-ℤ/2-CharacIso' m) g x))
-- --               (sym r))
-- -- RP→EM-ℤ/2-CharacIso-hom' (suc n) m f g =
-- --   funExt λ x → (λ i
-- --   → subst (EM ℤ/2)(+'-suc₁ (n + m))
-- --          (fst
-- --           (⌣RP∞'Equiv (n + m) .fst
-- --            (inv (RP→EM-ℤ/2-CharacIso' (n + m))
-- --             (tsa i))) x)
-- --     +ₖ (sum' _+ₖ_ ⌣ₖ₂' (fst f) (fst g) ((suc n) + m)))
-- --    ∙ (λ i → subst (EM ℤ/2)(+'-suc₁ (n + m))
-- --          (fst (⌣RP∞'Equiv (n + m) .fst
-- --            (RP→EM-ℤ/2-CharacIso-hom' n m (Π'↓ n (EM∙ ℤ/2) f) g i)) x)
-- --     +ₖ (lem1 i))
-- --    ∙ {!inv (RP→EM-ℤ/2-CharacIso' m) g x!}
-- --    ∙ sym (⌣ₖ₂'-distrₗ (suc n) m
-- --       (fst (⌣RP∞''Equiv n .fst  (inv (RP→EM-ℤ/2-CharacIso' n) (Π'↓ n (EM∙ ℤ/2) f))) x)
-- --       (idfun (EM ℤ/2 (suc n)) (fst f (suc n)))
-- --       (inv (RP→EM-ℤ/2-CharacIso' m) g x))
-- --   where
-- --   ⌣ₖ₂'-distrₗ : (n m : ℕ) (x y : EM ℤ/2 n) (z : EM ℤ/2 m)
-- --     → ⌣ₖ₂' n m (x +ₖ y) z ≡ ⌣ₖ₂' n m x z +ₖ ⌣ₖ₂' n m y z
-- --   ⌣ₖ₂'-distrₗ n m x y z = {!(inv (RP→EM-ℤ/2-CharacIso' m) (suc m) g x)!}
-- --   lem1 : sum' _+ₖ_ ⌣ₖ₂' (fst f) (fst g) ((suc n) + m)
-- --        ≡ ⌣ₖ₂' (suc n) m (fst f (suc n)) (fst g m)
-- --   lem1 = {!⌣ₖ₂' (suc n) m
-- --       (fst
-- --        (⌣RP∞''Equiv n .fst
-- --         (inv (RP→EM-ℤ/2-CharacIso' n) (Π'↓ n (EM∙ ℤ/2) (fst f , snd f))))
-- --        x
-- --        +ₖ idfun (EM ℤ/2 (suc n)) (fst f (suc n)))
-- --       (inv (RP→EM-ℤ/2-CharacIso' m) g x)!}

-- --   prs : (k : ℕ) → fst (fun (Π'-ind (n + m) (EM∙ ℤ/2)) (mult⌣ (suc n) m f g) .snd) k
-- --                   ≡ fst (mult⌣ n m (Π'↓ n (EM∙ ℤ/2) f) g) k
-- --   prs k = {! -- (Iso.inv (RP→EM-ℤ/2-CharacIso' m) g ?)!} -- Π↓-mult n m (EM∙ ℤ/2) (EM∙ ℤ/2) k _+ₖ_ ⌣ₖ₂' f (fst g)
-- --         ∙ {!!}

-- --   tsa : Iso.fun (Π'-ind (n + m) (EM∙ ℤ/2)) (mult⌣ (suc n) m f g) .snd
-- --       ≡ mult⌣ n m (Π'↓ n (EM∙ ℤ/2) f) g
-- --   tsa = Π'≡ (EM∙ ℤ/2) _
-- --     λ k p → {!!}

-- -- -- RP→EM-ℤ/2-CharacIso-hom' : (n m : ℕ) (x : _) (y : _)
-- -- --   → Iso.inv (RP→EM-ℤ/2-CharacIso (n + m)) (multˣ ⌣ₖ₂' n m x y)
-- -- --    ≡ λ a → ⌣ₖ₂' n m (Iso.inv (RP→EM-ℤ/2-CharacIso n) x a) (Iso.inv (RP→EM-ℤ/2-CharacIso m) y a)
-- -- -- RP→EM-ℤ/2-CharacIso-hom' zero m =
-- -- --   ℤ/2-elim
-- -- --     (λ y → cong (inv (RP→EM-ℤ/2-CharacIso m))
-- -- --               (multˣAnnₗ ⌣ₖ₂' 0ₖ (λ n m a → cong (subst (EM ℤ/2) (+'≡+ n m)) (0ₖ-⌣ₖ n m a)
-- -- --                               ∙ subst-EM∙ (+'≡+ n m)  .snd) zero m y)
-- -- --          ∙ cong (inv (RP→EM-ℤ/2-CharacIso m)) (sym (RP→EM-ℤ/2-CharacIso∙ m))
-- -- --          ∙ Iso.leftInv (RP→EM-ℤ/2-CharacIso m) (λ _ → 0ₖ m)
-- -- --          ∙ funExt λ a → sym (0ₖ-⌣ₖ₂' zero m (inv (RP→EM-ℤ/2-CharacIso m) y a)))
-- -- --     λ y → cong (inv (RP→EM-ℤ/2-CharacIso m))
-- -- --             (multˣIdL ⌣ₖ₂' fone (λ m a → transportRefl _ ∙ 1ₖ-⌣ₖ m a) m y)
-- -- --         ∙ funExt λ a → sym (1ₖ-⌣ₖ m (inv (RP→EM-ℤ/2-CharacIso m) y a))
-- -- --                       ∙ sym (transportRefl _)
-- -- -- RP→EM-ℤ/2-CharacIso-hom' (suc n) m (f , y) g =
-- -- --   funExt λ x → (λ i → fst (⌣RP∞''Equiv (n + m))
-- -- --                             (RP→EM-ℤ/2-CharacIso-hom' n m f g i) .fst x
-- -- --                          +ₖ ⌣ₖ₂' (suc n) m y (lastˣ (EM ℤ/2) m g))
-- -- --              ∙∙ (λ i → subst (EM ℤ/2) (+'-suc₁ (n + m))
-- -- --                           (⌣ₖ₂ {n = 1} {n + m} x
-- -- --                             (⌣ₖ₂' n m (inv (RP→EM-ℤ/2-CharacIso n) f x)
-- -- --                               (inv (RP→EM-ℤ/2-CharacIso m) g x)))
-- -- --                +ₖ ⌣ₖ₂' (suc n) m y (lastˣ (EM ℤ/2) m g))
-- -- --              ∙∙ {!subst (EM ℤ/2) (+'≡+ (suc n) m)
-- -- --       (⌣ₖ₂
-- -- --        (subst (EM ℤ/2) (+'-suc₁ n)
-- -- --         (⌣ₖ₂ x (inv (RP→EM-ℤ/2-CharacIso n) f x)))
-- -- --        (inv (RP→EM-ℤ/2-CharacIso m) g x)
-- -- --        +ₖ ⌣ₖ₂ y (inv (RP→EM-ℤ/2-CharacIso m) g x))!}
-- -- --                ∙ cong (subst (EM ℤ/2) (+'≡+ (suc n) m))
-- -- --                    ( (sym (help' n x (inv (RP→EM-ℤ/2-CharacIso n) f x) (inv (RP→EM-ℤ/2-CharacIso m) g x) y))) -- (sym (help' n x (inv (RP→EM-ℤ/2-CharacIso n) f x) (inv (RP→EM-ℤ/2-CharacIso m) g x) y .fst))
-- -- --              ∙∙ (λ i → subst (EM ℤ/2) (+'≡+ (suc n) m)
-- -- --                   (⌣ₖ₂ {n = suc n} {m = m} (subst (EM ℤ/2) (+'-suc₁ n)
-- -- --                      (⌣ₖ₂ {n = 1} {n} x (inv (RP→EM-ℤ/2-CharacIso n) f x)) +ₖ y)
-- -- --                      (inv (RP→EM-ℤ/2-CharacIso m) g x)))
-- -- --              ∙∙ λ i → ⌣ₖ₂' (suc n) m (fst (⌣RP∞''Equiv n) (inv (RP→EM-ℤ/2-CharacIso n) f) .fst x
-- -- --                 +ₖ y) (inv (RP→EM-ℤ/2-CharacIso m) g x)
-- -- --   where
-- -- --   help' : (n : ℕ) (x : EM ℤ/2 1) (f : EM ℤ/2 n) (g : EM ℤ/2 m) (y : EM ℤ/2 (suc n))
-- -- --     → (⌣ₖ₂ {n = suc n} {m = m}
-- -- --         (subst (EM ℤ/2) (+'-suc₁ n)
-- -- --           (⌣ₖ₂ {n = 1} {m = n} x f) +ₖ y) g
-- -- --       ≡ ⌣ₖ₂ {n = suc n} {m = m} (subst (EM ℤ/2) (+'-suc₁ n) (⌣ₖ₂ {n = 1} {m = n} x f)) g
-- -- --       +ₖ ⌣ₖ₂ {n = suc n} {m = m} y g)
-- -- --      -- × ((g' : EM ℤ/2 m)
-- -- --      --   → (subst (EM ℤ/2) (+'-suc₁ (n + m))
-- -- --      --      (⌣ₖ₂ x (⌣ₖ₂' n m f g))
-- -- --      --   +ₖ ⌣ₖ₂' (suc n) m y g'
-- -- --      -- ≡ {!!} +ₖ {!⌣ₖ₂' (suc n) m y g'!}))
-- -- --   help' n x = {!!}
-- -- --     where
-- -- --     c : {!!}
-- -- --     c = {!!}
-- -- --   main : (n m k l : ℕ) (x : EM ℤ/2 n) (y : EM ℤ/2 m) (z : EM ℤ/2 k) (w : EM ℤ/2 l)
-- -- --     → subst (EM ℤ/2) {!!} (⌣ₖ₂ x {!!}) +ₖ subst (EM ℤ/2) {!lastˣ (EM ℤ/2) m !} (⌣ₖ₂ y w) ≡ {!⌣ₖ₂' (suc n) m y (lastˣ (EM ℤ/2) m g)!}
-- -- --   main = {!!}
-- -- -- {-
-- -- -- Goal: fst
-- -- --       (inv (Cubical.Cohomology.EilenbergMacLane.Rings.RPinf.help (n + m))
-- -- --        (inv (RP→EM-ℤ/2-CharacIso (n + m)) (multˣ ⌣ₖ₂' n m (fst f) g)))
-- -- --       x
-- -- --       +ₖ
-- -- --       idfun (EM ℤ/2 (suc (n + m)))
-- -- --       (⌣ₖ₂' (suc n) m (snd f) (lastˣ (EM ℤ/2) m g))
-- -- --       ≡
-- -- --       ⌣ₖ₂' (suc n) m
-- -- --       (fst
-- -- --        (inv (Cubical.Cohomology.EilenbergMacLane.Rings.RPinf.help n)
-- -- --         (inv (RP→EM-ℤ/2-CharacIso n) (fst f)))
-- -- --        x
-- -- --        +ₖ idfun (EM ℤ/2 (suc n)) (snd f))
-- -- --       (inv (RP→EM-ℤ/2-CharacIso m) g x)
-- -- -- -}




-- -- -- RP→EM-ℤ/2-CharacIso-hom : (n m : ℕ)
-- -- --   (f : EM ℤ/2 1 → EM ℤ/2 n) (g : EM ℤ/2 1 → EM ℤ/2 m)
-- -- --   → Iso.fun (RP→EM-ℤ/2-CharacIso (n + m)) (λ x → ⌣ₖ₂' n m (f x) (g x))
-- -- --    ≡ multˣ ⌣ₖ₂' n m (Iso.fun (RP→EM-ℤ/2-CharacIso n) f)
-- -- --                 (Iso.fun (RP→EM-ℤ/2-CharacIso m) g)
-- -- -- RP→EM-ℤ/2-CharacIso-hom zero m f g = {!!}
-- -- -- RP→EM-ℤ/2-CharacIso-hom (suc n) m f g = {!!}
