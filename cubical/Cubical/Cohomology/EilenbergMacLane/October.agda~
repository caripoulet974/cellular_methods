{-# OPTIONS --safe --lossy-unification #-}

{-
This file contains
1. The Thom isomorphism (various related forms of it)
2. The Gysin sequence
-}
open import Cubical.Cohomology.EilenbergMacLane.Base
open import Cubical.Cohomology.EilenbergMacLane.Groups.Sn
open import Cubical.Cohomology.EilenbergMacLane.CupProduct

open import Cubical.Homotopy.EilenbergMacLane.CupProduct
open import Cubical.Homotopy.EilenbergMacLane.CupProductTensor
  renaming (_⌣ₖ_ to _⌣ₖ⊗_ ; ⌣ₖ-0ₖ to ⌣ₖ-0ₖ⊗ ; 0ₖ-⌣ₖ to 0ₖ-⌣ₖ⊗)
open import Cubical.Homotopy.Connected
open import Cubical.Homotopy.EilenbergMacLane.GradedCommTensor
  hiding (⌣ₖ-comm)
open import Cubical.Homotopy.EilenbergMacLane.GroupStructure
open import Cubical.Homotopy.EilenbergMacLane.Base
open import Cubical.Homotopy.EilenbergMacLane.Properties
open import Cubical.Homotopy.Loopspace
open import Cubical.Homotopy.Group.Base

open import Cubical.Functions.Morphism
open import Cubical.Functions.Embedding
open import Cubical.Functions.Surjection

open import Cubical.Foundations.Prelude
open import Cubical.Foundations.Transport
open import Cubical.Foundations.HLevels
open import Cubical.Foundations.Function
open import Cubical.Foundations.GroupoidLaws
open import Cubical.Foundations.Path
open import Cubical.Foundations.Equiv
open import Cubical.Foundations.Pointed
open import Cubical.Foundations.Pointed.Homogeneous
open import Cubical.Foundations.Isomorphism

open import Cubical.HITs.PropositionalTruncation as PT
open import Cubical.HITs.SetTruncation as ST
open import Cubical.HITs.Truncation as TR
open import Cubical.HITs.Sn
open import Cubical.HITs.Pushout
open import Cubical.HITs.EilenbergMacLane1.Base
open import Cubical.HITs.Susp
open import Cubical.HITs.S1

open import Cubical.Data.Unit
open import Cubical.Data.Nat
open import Cubical.Data.Nat.Order hiding (eq)
open import Cubical.Data.Sigma
open import Cubical.Data.Bool hiding (_≤_)

open import Cubical.Algebra.Group.Base
open import Cubical.Algebra.AbGroup.Base
open import Cubical.Algebra.Group.MorphismProperties
open import Cubical.Algebra.Group.Morphisms
open import Cubical.Algebra.Ring
open import Cubical.Algebra.CommRing

open import Cubical.HITs.RPn
open import Cubical.Homotopy.EilenbergMacLane.Order2

open import Cubical.Relation.Nullary
open import Cubical.Relation.Nullary.HLevels
open import Cubical.Foundations.Function
open import Cubical.Data.Sum as ⊎
open import Cubical.Data.Empty as ⊥
open import Cubical.HITs.SmashProduct

open import Cubical.Cohomology.EilenbergMacLane.GenSmash

open import Cubical.Foundations.Univalence
open import Cubical.Cohomology.EilenbergMacLane.Steenrod5

module Cubical.Cohomology.EilenbergMacLane.October where
open import Cubical.HITs.Join
open import Cubical.Functions.FunExtEquiv
open import Cubical.Functions.FunExtEquiv

{-
ΠR-extend→Π-equiv : ∀ {ℓ} (I J : RP∞' ℓ) (A : fst I → fst J → Type ℓ)
  → isEquiv (2-elter.ΠR-extend→Π I (fst J) A)
ΠR-extend→Π-equiv {ℓ} =
  RP∞'pt→Prop (λ _ → isPropΠ2 λ _ _ → isPropIsEquiv _) ΠR-extend→Π-equiv-base
-}

makeRP'≃ₗ : {ℓ : Level} (J : RP∞' ℓ) (j : fst J) → Bool ≃ (fst J)
makeRP'≃ₗ J j = isoToEquiv (iso F G GFG FGF)
  where
  R = J .snd .fst .snd .snd (λ _ → Lift Bool)
  G' : fst J → Lift Bool
  G' = R .fst j (lift true) (lift false)

  G : fst J → Bool
  G = lower ∘ G'

  F : Bool → fst J
  F = CasesBool true j (J .snd .fst .fst j)

  FGF : (x : Bool) → G (F x) ≡ x
  FGF false = cong lower (R .snd j (lift true) (lift false) .snd)
  FGF true = cong lower (R .snd j (lift true) (lift false) .fst)

  GFG : (x : _) → F (G x) ≡ x
  GFG x = lower (J .snd .fst .snd .snd (λ x → Lift (F (G x) ≡ x)) .fst
                j
                (lift (cong F (cong lower (R .snd j (lift true) (lift false) .fst))))
                (lift (cong F (cong lower (R .snd j (lift true) (lift false) .snd)))) x)

module _  {ℓ} (J : RP∞' ℓ) (A : Bool → fst J → Type ℓ) where

  module JLem = 2-elter' J Bool (λ x y → A y x)

  Lift↓ : Lift {j = ℓ} (fst J ⊎ (Bool ≃ fst J)) → fst J ⊎ (Bool ≃ fst J)
  Lift↓  (lift x) = x

  →⊎ : fst J → fst J → fst J ⊎ (Bool ≃ fst J)
  →⊎ x = Lift↓ ∘ JLem.elimI x (lift (inl x)) (lift (inr (makeRP'≃ₗ J x)))

  inl-inl : (j1 j2 : fst J) → A true j1 → A false j2
    → Σ[ e ∈ (fst J ⊎ (Bool ≃ fst J)) ]
          ((i : Bool) → A i (2-elter'.eval (RP∞'· ℓ) (fst J) A e i))
  inl-inl j1 =
    JLem.elimI {B = λ j2 → A true j1 → A false j2
                         → Σ[ e ∈ (fst J ⊎ (Bool ≃ fst J)) ]
                               ((i : Bool) → A i (2-elter'.eval (RP∞'· ℓ) (fst J) A e i))}
      j1 (λ a b → (inl j1) , CasesBool true a b)
          λ a b → inr (makeRP'≃ₗ J j1) , CasesBool true a b

  inl-inlₗ : (j1 : fst J) (x : A true j1) (y : A false j1)
    → inl-inl j1 j1 x y ≡ ((inl j1) , CasesBool true x y)
  inl-inlₗ j1 x y i =
    (JLem.elimIβ {B = λ j2 → A true j1 → A false j2
                         → Σ[ e ∈ (fst J ⊎ (Bool ≃ fst J)) ]
                               ((i : Bool) → A i (2-elter'.eval (RP∞'· ℓ) (fst J) A e i))}
      j1 (λ a b → (inl j1) , CasesBool true a b)
          λ a b → inr (makeRP'≃ₗ J j1) , CasesBool true a b) .fst i x y


  inl-inl1 : {!JLem.elimI ? ? ?!}
  inl-inl1 = {!!}

  inl-pushₗ : (j1 : fst J) (x : A true j1) (y : A false j1)
    → (f : TotΠ (A false)) (p : f j1 ≡ y)
    → Path (2-elter'.ΠR-extend (RP∞'· ℓ) (fst J) A)
            (inr (inl (inl-inl j1 j1 x y)))
            (inr (inl (inl j1 , CasesBool true x (f j1))))
  inl-pushₗ j1 x y f p i = inr (inl ((inl-inlₗ j1 x y ∙ λ i → (inl j1 , (CasesBool true x (p (~ i))))) i))

  inl-pushᵣ : (j1 : fst J) (x : A true j1) (y : A false (JLem.notI j1))
    → (f : TotΠ (A false)) (p : f (JLem.notI j1) ≡ y)
    → Path (2-elter'.ΠR-extend (RP∞'· ℓ) (fst J) A)
            (inr (inl (inl-inl j1 (JLem.notI j1) x y)))
            (inr (inl (inl j1 , CasesBool true x (f j1))))
  inl-pushᵣ j1 x y f p = {!!}


  inl-push : (j1 j2 : fst J) (x : A true j1) (y : A false j2)
    → (f : TotΠ (A false)) (p : f j2 ≡ y)
    → Path (2-elter'.ΠR-extend (RP∞'· ℓ) (fst J) A)
            (inr (inl (inl-inl j1 j2 x y)))
            (inr (inl (inl j1 , CasesBool true x (f j1))))
  inl-push j1 = JLem.elimI j1 (inl-pushₗ j1) {!!}

  ×→ΠR-extend* :
    joinR-gen (fst J) (A true) × joinR-gen (fst J) (A false)
    → 2-elter'.ΠR-extend (RP∞'· ℓ) (fst J) A
  ×→ΠR-extend* (inlR (j1 , x) , inlR (j2 , y)) = inr (inl (inl-inl j1 j2 x y))
  ×→ΠR-extend* (inlR x , inrR f) = inr (inl ((inl (fst x)) , (CasesBool true (snd x) (f (fst x)))))
  ×→ΠR-extend* (inlR (j1 , x) , push* (j2 , y) f p i) = inl-push j1 j2 x y f p i
  ×→ΠR-extend* (inrR f , inlR x) = inr (inl ((inl (fst x)) , (CasesBool true (f (fst x)) (snd x))))
  ×→ΠR-extend* (inrR x , inrR x₁) = inr (inr (CasesBool true x x₁))
  ×→ΠR-extend* (inrR x , push* a b x₁ i) = inr {!!}
  ×→ΠR-extend* (push* a b₁ x i , b) = {!!}

{-
×→ΠR-extend* : ∀ {ℓ} (J : RP∞' ℓ) (A : Bool → fst J → Type ℓ)
  → joinR-gen (fst J) (A true) × joinR-gen (fst J) (A false)
  → 2-elter'.ΠR-extend (RP∞'· ℓ) (fst J) A
×→ΠR-extend* J A (inlR x , inlR x₁) = inr (inl (CasesBool true x x₁))
×→ΠR-extend* J A (inlR (x , b) , inrR x₁) = inl (true , ((_ , b) , x₁))
×→ΠR-extend* J A (inlR (a , b) , push* (a' , d) c x₁ i) =
  push (true , inl ((CasesBool true (a , b) (a' , d)) , c , x₁)) (~ i)
×→ΠR-extend* J A (inrR x , inlR x₁) = inl (false , (x₁ , x))
×→ΠR-extend* J A (inrR x , inrR x₁) = inr (inr (CasesBool true x x₁))
×→ΠR-extend* J A (inrR x , push* (a , b) c x₁ i) =
  push (false , (inr ((a , b) , ((CasesBool true x c) , x₁)))) i
×→ΠR-extend* J A (push* (a , b) c x i , inlR (a' , b')) =
  push (false , inl ((CasesBool true (a , b) (a' , b')) , (c , x))) (~ i)
×→ΠR-extend* J A (push* (a' , b) c x i , inrR x₁) =
  push (true , inr ((_ , b) , (CasesBool true c x₁ , x))) i
×→ΠR-extend* J A (push* (a , b) c x i , push* (a' , b₁) c₁ d i₁) =
  ?
-}
-- module _ {ℓ : Level} (I J : RP∞' ℓ) (A : fst I → fst J → Type ℓ) where
--   private
--     module 1st = 2-elter I (fst J) A
--     module 2nd = 2-elter' I (fst J) A

--   ΠR-extend→M : 2nd.ΠR-extend → joinR-gen (fst J) λ j → joinR-gen (fst I) (λ i → A i j)
--   ΠR-extend→M (inl x) = {!!}
--   ΠR-extend→M (inr x) = {!!}
--   ΠR-extend→M (push a i) = {!!}


-- eval⁻ : ∀ {ℓ} (I J : RP∞' ℓ) → fst J ⊎ (fst I ≃ fst J) → fst I → fst J
-- eval⁻ I J (inl j) _ = j
-- eval⁻ I J (inr f) = fst f

-- isEqEval : ∀ {ℓ} (I J : RP∞' ℓ) → isEquiv (eval⁻ I J)
-- isEqEval = RP∞'pt→Prop (λ _ → isPropΠ λ _ → isPropIsEquiv _)
--   {!λ !}
--   where
--   main : ∀ {ℓ} (J : RP∞' ℓ) → (Bool → fst J) → fst J ⊎ (Bool ≃ fst J)
--   main J f = {!!}

-- eval' : ∀ {ℓ} (I J : RP∞' ℓ) (A : fst I → fst J → Type ℓ)
--   → Iso ((i : fst I) → Σ (fst J) (A i))
--          ((Σ[ j ∈ fst J ] ((i : fst I) → A i j))
--        ⊎ (Σ[ t ∈ (fst I ≃ fst J) ] ((i : fst I) → A i (fst t i))))
-- Iso.fun (eval' I J A) f =
--   ⊎.rec (λ j → inl (j , λ i → {!f i .snd!})) {!!} (invEq (_ , isEqEval I J) (fst ∘ f))
-- Iso.inv (eval' I J A) = {!!}
-- Iso.rightInv (eval' I J A) = {!!}
-- Iso.leftInv (eval' I J A) = {!!}

-- module _ {ℓ} (I J : RP∞' ℓ) (A : fst I → fst J → Type ℓ) where
--   module IM = 2-elter I (fst J) A
--   open IM
--   module JM = 2-elter J

--   TYP = 2-elter.ΠR-extend I (fst J) A
--   GOAL = joinR-gen (fst J) λ j → joinR-gen (fst I) λ i → A i j

--   sₗ : left-push → GOAL
--   sₗ (i , (j , a) , f) = inlR (j , inrR (elimI i a (f j)))

--   sᵣ : ΠR-base → GOAL
--   sᵣ (inl f) = inrR λ j → inrR λ i → JM.elimI (fst I) (λ x y → A y x) {B = λ j → A i j} (fst (f i)) (f i .snd) {!f i .snd!} j
--   sᵣ (inr x) = inrR λ j → inrR λ i → x i j
--   sᵣ (push a i) = {!a!}

--   s : TYP → joinR-gen (fst J) λ j → joinR-gen (fst I) λ i → A i j
--   s (inl x) = sₗ x
--   s (inr x) = sᵣ x
--   s (push (i , inl x) k) = {!!}
--   s (push (i , inr x) k) = {!!}
--   s (push (i , push a i₁) k) = {!!}
  

